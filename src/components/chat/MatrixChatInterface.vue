<template>
  <div class="matrix-chat-interface" :class="[`mode-${mode}`]" data-cy="matrix-chat-interface">
    <!-- Chat Header (for inline mode only - mobile header is handled by parent) -->
    <div
      v-if="mode === 'inline'"
      class="chat-header q-pa-md"
    >
      <div class="row items-center">
        <div class="col">
          <div class="text-subtitle1">{{ roomName || 'Chat Room' }}</div>
          <div class="text-caption">
            {{ getRoomStatusText() }}
          </div>
        </div>
        <q-btn
          icon="sym_r_more_vert"
          flat
          round
        >
          <q-menu>
            <q-list style="min-width: 180px">
              <q-item clickable v-close-popup @click="clearMatrixSessions">
                <q-item-section avatar>
                  <q-icon name="sym_r_clear_all" />
                </q-item-section>
                <q-item-section>
                  <q-item-label>Clear Matrix Sessions</q-item-label>
                  <q-item-label caption>Fix authentication issues</q-item-label>
                </q-item-section>
              </q-item>
              <q-item clickable v-close-popup @click="reconnect">
                <q-item-section avatar>
                  <q-icon name="sym_r_refresh" />
                </q-item-section>
                <q-item-section>
                  <q-item-label>Reconnect</q-item-label>
                  <q-item-label caption>Retry connection</q-item-label>
                </q-item-section>
              </q-item>
              <q-separator />
              <q-item clickable v-close-popup @click="showChatHelp">
                <q-item-section avatar>
                  <q-icon name="sym_r_help" />
                </q-item-section>
                <q-item-section>
                  <q-item-label>Chat Help</q-item-label>
                  <q-item-label caption>Use other Matrix clients</q-item-label>
                </q-item-section>
              </q-item>
            </q-list>
          </q-menu>
        </q-btn>
        <q-btn
          icon="sym_r_open_in_new"
          flat
          round
          @click="$emit('expand')"
        />
      </div>
    </div>

    <!-- Messages Container -->
    <div
      class="messages-container q-pa-md"
      :style="getMessagesContainerStyle()"
      ref="messagesContainer"
      data-cy="messages-container"
    >
      <!-- Connection Status -->
      <div v-if="!isConnected" class="connection-status text-center q-pa-md">
        <q-spinner v-if="isConnecting" size="24px" />
        <div class="text-body2 text-grey-6 q-mt-sm">
          {{ isConnecting ? 'Connecting to chat...' : getRoomStatusText() }}
        </div>
        <div v-if="hasOidcConfigError()" class="text-caption text-orange q-mt-sm">
          Matrix chat server configuration issue. Please contact support.
        </div>
        <q-btn
          v-if="!isConnecting && !hasOidcConfigError()"
          :label="getConnectButtonLabel()"
          color="primary"
          outline
          size="sm"
          @click="reconnect"
          :disable="isRateLimited()"
          class="q-mt-sm"
          data-cy="matrix-connect-button"
        />
      </div>

      <!-- Historical Message Encryption Handler -->
      <HistoricalMessageHandler
        v-if="isConnected"
        :auto-prompt="true"
        :show-status="true"
      />

      <!-- Messages -->
      <div v-if="isConnected && messages.length > 0" class="messages-list" data-cy="messages-list">
        <!-- Load More History Button -->
        <div class="load-more-history text-center q-pa-md">
          <q-btn
            v-if="!isLoadingOlderMessages && hasMoreHistory"
            @click="loadOlderMessages"
            label="Load More History"
            icon="sym_r_keyboard_arrow_up"
            color="primary"
            outline
            size="sm"
            dense
            data-cy="load-more-history-btn"
          />
          <div v-if="isLoadingOlderMessages" class="loading-older-messages text-center q-pa-sm">
            <q-spinner size="20px" color="primary" />
            <div class="text-caption text-grey-6 q-mt-xs">Loading older messages...</div>
          </div>
          <div v-if="!hasMoreHistory && messages.length > 4" class="text-caption text-grey-6">
            No more history available
          </div>
        </div>

        <!-- Loading indicator for initial messages -->
        <div v-if="isLoading && messages.length === 0" class="loading-older-messages text-center q-pa-md">
          <q-spinner size="20px" color="primary" />
          <div class="text-caption text-grey-6 q-mt-xs">Loading messages...</div>
        </div>

        <div
          v-for="message in messages"
          :key="message.id"
          class="message-item"
          :class="getMessageClass(message)"
        >
          <div class="row q-gutter-sm no-wrap">
            <!-- Avatar -->
            <q-avatar
              :size="mode === 'mobile' ? '32px' : '40px'"
              v-if="!message.isOwn || mode === 'desktop'"
              class="message-avatar"
            >
              <img v-if="message.sender.avatar" :src="message.sender.avatar" />
              <div v-else class="avatar-fallback" :style="{ backgroundColor: getSenderColor(message.sender.id) }">
                {{ message.sender.name?.charAt(0)?.toUpperCase() || '?' }}
              </div>
            </q-avatar>

            <!-- Message Content -->
            <div class="message-content" :class="{ 'own-message': message.isOwn }">
              <!-- Sender Name (for group chats) -->
              <div
                v-if="!message.isOwn && showSenderNames"
                class="sender-name q-mb-xs row items-baseline"
              >
                <div class="text-weight-bold sender-display-name" :style="{ color: getSenderColor(message.sender.id) }">
                  {{ cleanDisplayName(message.sender.name, message.sender.id) }}
                </div>
                <div class="message-time text-caption q-ml-sm">
                  {{ formatTime(message.timestamp) }}
                </div>
              </div>

              <!-- Message Body -->
              <div class="message-body">
                <!-- Text Message -->
                <div v-if="message.type === 'text'" class="text-message">
                  <div class="message-text" v-html="formatMessageText(message.content.body)"></div>
                  <!-- Status and actions - show for own messages and admins -->
                  <div v-if="shouldShowMessageActions(message)" class="message-actions text-caption q-mt-xs">
                    <!-- Status and read receipts - only for own messages -->
                    <template v-if="message.isOwn">
                      <q-icon
                        :name="getMessageStatusIcon(message.status)"
                        :color="getMessageStatusColor(message.status)"
                        size="12px"
                      >
                        <q-tooltip v-if="message.status === 'failed'" class="text-body2">
                          {{ message.errorMessage || 'Failed to send message. Click to retry.' }}
                        </q-tooltip>
                      </q-icon>
                      <!-- Read Receipt Indicators -->
                      <q-chip
                        v-if="message.readReceipts && message.readReceipts.length > 0"
                        dense
                        size="10px"
                        color="primary"
                        text-color="white"
                        class="read-receipts-chip q-ml-xs"
                      >
                        <q-tooltip class="text-body2">
                          Read by: {{ message.readReceipts.map(r => r.userName).join(', ') }}
                        </q-tooltip>
                        <q-icon name="fas fa-eye" size="xs" class="q-mr-xs" />
                        <span class="read-receipt-text">
                          {{ message.readReceipts.length }} read
                        </span>
                      </q-chip>
                    </template>

                    <!-- Delete button - available for message owners and admins -->
                    <q-icon
                      v-if="canDeleteMessage(message)"
                      name="fas fa-trash"
                      size="10px"
                      color="negative"
                      class="delete-message-btn q-ml-xs cursor-pointer"
                      @click="deleteMessage(message)"
                    >
                      <q-tooltip class="text-body2">Delete message</q-tooltip>
                    </q-icon>
                  </div>
                </div>

                <!-- Image Message -->
                <div v-else-if="message.type === 'image'" class="image-message">
                  <div v-if="message.imageBlobUrl" class="authenticated-image-container">
                    <img
                      :src="message.imageBlobUrl"
                      :alt="message.content.filename"
                      class="message-image cursor-pointer"
                      :style="getImageStyle()"
                      @click="showImageModal(message.fullImageBlobUrl || message.imageBlobUrl)"
                    />
                  </div>
                  <div v-else class="image-loading">
                    <q-spinner color="primary" size="2em" />
                    <div class="text-caption q-mt-xs">Loading image...</div>
                  </div>
                  <div v-if="message.content.filename" class="text-caption q-mt-xs">
                    {{ message.content.filename }}
                  </div>
                </div>

                <!-- File Message -->
                <div v-else-if="message.type === 'file'" class="file-message">
                  <q-card flat bordered class="file-card">
                    <q-card-section class="q-pa-sm">
                      <div class="row items-center">
                        <q-icon :name="getFileIcon(message.content.mimetype)" class="q-mr-sm" size="24px" />
                        <div class="col">
                          <div class="text-body2 file-name">{{ message.content.filename }}</div>
                          <div class="text-caption text-grey-6">
                            {{ formatFileSize(message.content.size) }}
                          </div>
                        </div>
                        <div class="file-actions">
                          <q-btn
                            icon="sym_r_visibility"
                            flat
                            round
                            size="sm"
                            @click="previewFile(message.content)"
                            :title="'Preview ' + message.content.filename"
                            class="q-mr-xs"
                          />
                          <q-btn
                            icon="sym_r_download"
                            flat
                            round
                            size="sm"
                            @click="downloadFile(getFileUrl(message.content.url), message.content.filename)"
                            :title="'Download ' + message.content.filename"
                          />
                        </div>
                      </div>
                    </q-card-section>
                  </q-card>
                </div>
              </div>

            </div>
          </div>
        </div>
      </div>

      <!-- Empty State with Load More History -->
      <div v-else-if="isConnected && messages.length === 0" class="empty-state text-center q-pa-lg">
        <!-- Load More History Button (show even when no messages) -->
        <div v-if="isConnected" class="load-more-history text-center q-pa-md">
          <q-btn
            v-if="!isLoadingOlderMessages && hasMoreHistory"
            @click="loadOlderMessages"
            label="Load More History"
            icon="sym_r_keyboard_arrow_up"
            color="primary"
            outline
            size="sm"
            dense
            data-cy="load-more-history-btn"
          />
          <div v-if="isLoadingOlderMessages" class="loading-older-messages text-center q-pa-sm">
            <q-spinner size="20px" color="primary" />
            <div class="text-caption text-grey-6 q-mt-xs">Loading older messages...</div>
          </div>
          <div v-if="!hasMoreHistory" class="text-caption text-grey-6 q-mb-md">
            No history available
          </div>
        </div>

        <q-icon name="fas fa-comments" size="48px" color="grey-5" />
        <div class="text-h6 q-mt-md text-grey-6">Start the conversation</div>
        <div class="text-body2 text-grey-5">Send a message to begin</div>

        <!-- Simplified: Use the unified connect button instead of separate join room button -->
      </div>

      <!-- Typing Indicators -->
      <div v-if="typingUsers.length > 0" class="typing-indicator q-mt-md">
        <div class="row items-center q-gutter-xs">
          <!-- Show avatars for up to 3 typing users -->
          <div v-for="user in typingUsers.slice(0, 3)" :key="user.userId" class="typing-user-avatar">
            <q-avatar size="24px">
              <div class="avatar-fallback typing-avatar" :style="{ backgroundColor: getSenderColor(user.userId) }">
                {{ user.userName?.charAt(0)?.toUpperCase() || '?' }}
              </div>
            </q-avatar>
          </div>
          <!-- Show typing dots animation -->
          <div class="typing-dots-container q-mr-sm">
            <q-icon name="fas fa-ellipsis-h" size="16px" class="typing-dots" color="grey-6" />
          </div>
          <!-- Show typing text -->
          <span class="text-caption text-grey-6 typing-text">
            {{ formatTypingUsers(typingUsers) }}
          </span>
        </div>
      </div>
    </div>

    <!-- Typing Notification Badge (when user is viewing older messages) -->
    <div v-if="showTypingNotification && typingUsers.length > 0" class="typing-notification-badge">
      <q-btn
        :label="`${formatTypingUsers(typingUsers)} - Scroll to see`"
        icon="keyboard_arrow_down"
        color="primary"
        size="sm"
        rounded
        @click="scrollToBottom(true)"
        class="typing-scroll-btn"
      />
    </div>

    <!-- Message Input -->
    <div class="message-input-container">
      <div class="message-input q-pa-md">
        <div class="row items-end q-gutter-sm">
          <!-- File Upload Button -->
          <q-btn
            :icon="isSending ? 'fas fa-spinner fa-spin' : 'fas fa-paperclip'"
            flat
            round
            :size="mode === 'mobile' ? 'md' : 'sm'"
            @click="triggerFileUpload"
            :disable="!canSendMessages || isSending"
            :title="isSending ? 'Uploading file...' : 'Attach file'"
          />
          <q-file
            ref="fileInput"
            v-model="selectedFile"
            style="display: none;"
            accept="*/*"
          />

          <!-- Message Input Field -->
          <q-input
            ref="messageInput"
            v-model="messageText"
            :placeholder="getInputPlaceholder()"
            dense
            outlined
            autogrow
            :rows="1"
            :max-height="100"
            class="col"
            :disable="!canSendMessages"
            @keydown.enter.exact.prevent="sendMessage"
            @keydown="handleTyping"
            @blur="stopTyping"
            data-cy="chat-input"
          >
            <!-- Emoji Picker Button -->
            <template v-slot:prepend>
              <q-btn
                icon="fas fa-smile"
                flat
                round
                size="sm"
                @click="showEmojiPicker = !showEmojiPicker"
                :disable="!canSendMessages"
              />
            </template>
          </q-input>

          <!-- Send Button -->
          <q-btn
            icon="sym_r_send"
            color="primary"
            round
            :size="mode === 'mobile' ? 'md' : 'sm'"
            @click="sendMessage"
            :loading="isSending"
            :disable="!canSendMessage"
            data-cy="send-button"
          />
        </div>

        <!-- Sending Progress Indicator -->
        <div v-if="isSending" class="upload-progress q-mt-sm">
          <q-linear-progress
            indeterminate
            color="primary"
            size="2px"
            class="q-mb-xs"
          />
          <div class="text-caption text-grey-6 text-center">
            <q-icon name="fas fa-paper-plane" size="xs" class="q-mr-xs" />
            Sending message...
          </div>
        </div>

        <!-- Emoji Picker -->
        <div v-if="showEmojiPicker" class="emoji-picker q-mt-sm">
          <div class="emoji-grid q-pa-sm bg-grey-1 rounded-borders">
            <q-btn
              v-for="emoji in commonEmojis"
              :key="emoji"
              :label="emoji"
              flat
              size="sm"
              @click="addEmoji(emoji)"
              class="emoji-btn"
            />
          </div>
        </div>
      </div>
    </div>

    <!-- Image Modal -->
    <q-dialog v-model="imageModal" maximized>
      <q-card>
        <q-card-section class="row items-center">
          <q-space />
          <q-btn icon="sym_r_close" flat round dense v-close-popup />
        </q-card-section>
        <q-card-section class="q-pa-none flex flex-center">
          <img :src="imageModalSrc" style="max-width: 100%; max-height: 90vh;" />
        </q-card-section>
      </q-card>
    </q-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, nextTick, watch } from 'vue'
import { useQuasar } from 'quasar'
import { format } from 'date-fns'
import { MatrixEvent, Room, ClientEvent, RoomEvent, MatrixEventEvent } from 'matrix-js-sdk'
import { CryptoEvent } from 'matrix-js-sdk/lib/crypto-api'
import { matrixClientService } from '../../services/matrixClientService'
import { matrixClientManager } from '../../services/MatrixClientManager'
import { matrixEncryptionService } from '../../services/MatrixEncryptionService'
import getEnv from '../../utils/env'
import { logger } from '../../utils/logger'
import HistoricalMessageHandler from './encryption/HistoricalMessageHandler.vue'

// Add type declaration for global window property
declare global {
  interface Window {
    matrixRetryAfter?: number;
  }
}

interface Message {
  id: string
  type: 'text' | 'image' | 'file'
  sender: {
    id: string
    name: string
    avatar?: string
  }
  content: {
    body?: string
    url?: string
    filename?: string
    mimetype?: string
    size?: number
    msgtype?: string
  }
  timestamp: Date
  isOwn: boolean
  status?: 'sending' | 'sent' | 'delivered' | 'read' | 'failed'
  readReceipts?: Array<{ userId: string, userName: string, timestamp: number }>
  isRedacted?: boolean
  errorMessage?: string
  // Authenticated image blob URLs
  imageBlobUrl?: string
  fullImageBlobUrl?: string
}

interface Props {
  roomId: string
  contextType: 'direct' | 'group' | 'event'
  contextId: string
  mode: 'desktop' | 'mobile' | 'inline'
  height?: string
}

const props = withDefaults(defineProps<Props>(), {
  height: '400px'
})

defineEmits<{
  'back': []
  'expand': []
}>()

// Quasar instance for dark mode detection
const quasar = useQuasar()

// State
const messageText = ref('')
const selectedFile = ref<File | null>(null)
const messages = ref<Message[]>([])
const typingUsers = ref<{ userId: string, userName: string }[]>([])
// Connection state tracking

const isConnected = computed(() => {
  const client = matrixClientService.getClient()
  const isReady = matrixClientService.isReady()
  const isLoggedIn = client?.isLoggedIn() ?? false

  // Consider connected if we have a resolved room and no auth errors
  // This handles cases where Matrix client restarts but we're still functional
  const hasResolvedRoom = !!currentRoom.value
  const noAuthErrors = !lastAuthError.value

  return (isReady && isLoggedIn) || (hasResolvedRoom && noAuthErrors)
})
const isConnecting = ref(false)
const isSending = ref(false)
const showEmojiPicker = ref(false)
const imageModal = ref(false)
const imageModalSrc = ref('')
const roomName = ref('')
const canSendMessages = ref(true)
const rateLimitCountdown = ref(0)
const lastAuthError = ref('')
const showTypingNotification = ref(false)
const lastReadReceiptSent = ref<string | null>(null)
const messageCount = ref(0)
const typingNotificationTimer = ref<number | null>(null)

// Load More History state
const isLoadingOlderMessages = ref(false)
const hasMoreHistory = ref(true)
const currentHistoryLimit = ref(50)

// Use Matrix client service directly for real Matrix integration

// Refs
const messagesContainer = ref<HTMLElement>()
const messageInput = ref()
const fileInput = ref()
const countdownTimer = ref<ReturnType<typeof setInterval> | null>(null)

// Custom event listeners tracking for cleanup
let customEventListeners: (() => void)[] = []

// Helper function to resolve room aliases to actual Matrix rooms
const resolveRoom = async (roomIdOrAlias: string) => {
  const client = matrixClientService.getClient()
  if (!client) return null

  // First, try direct room ID lookup (for cached room IDs)
  if (roomIdOrAlias.startsWith('!')) {
    return client.getRoom(roomIdOrAlias)
  }

  // If it's a room alias, try to resolve it
  if (roomIdOrAlias.startsWith('#')) {
    try {
      // First check if we already have a room with this alias
      const rooms = client.getRooms()
      for (const room of rooms) {
        if (room.getCanonicalAlias() === roomIdOrAlias ||
            room.getAltAliases().includes(roomIdOrAlias)) {
          return room
        }
      }

      // If not found locally, resolve the alias via Matrix API
      // Resolving room alias
      const aliasResponse = await client.getRoomIdForAlias(roomIdOrAlias)
      const roomId = aliasResponse.room_id

      // Try to get the room by resolved ID
      let room = client.getRoom(roomId)

      // If room still not found locally, join via alias
      if (!room) {
        // Room not in local state, joining via alias
        const joinResult = await client.joinRoom(roomIdOrAlias)
        room = client.getRoom(joinResult.roomId)
      }

      return room
    } catch (error) {
      logger.error('Failed to resolve room alias:', roomIdOrAlias, error)
      return null
    }
  }

  // Fallback: try as room ID anyway
  return client.getRoom(roomIdOrAlias)
}

// Reactive room reference that resolves aliases
const currentRoom = ref<Room | null>(null)
const isResolvingRoom = ref(false)

// Function to update the current room when roomId changes
const updateCurrentRoom = async () => {
  if (!props.roomId || isResolvingRoom.value) return

  isResolvingRoom.value = true
  try {
    const room = await resolveRoom(props.roomId)
    currentRoom.value = room
    if (room) {
      // Resolved room successfully
    } else {
      logger.warn('Could not resolve room:', props.roomId)
    }
  } catch (error) {
    logger.error('Error resolving room:', error)
    currentRoom.value = null
  } finally {
    isResolvingRoom.value = false
  }
}

// Watch for roomId changes and resolve the room
watch(() => props.roomId, updateCurrentRoom, { immediate: true })

// Mock data
const commonEmojis = ['😀', '😊', '😂', '❤️', '👍', '👏', '🎉', '🔥', '💯', '🤔', '😎', '👋']
const senderColors = {
  light: ['#1976d2', '#388e3c', '#f57c00', '#7b1fa2', '#d32f2f', '#455a64'],
  dark: ['#64b5f6', '#81c784', '#ffb74d', '#ba68c8', '#f48fb1', '#90a4ae']
}

// Computed
const canSendMessage = computed(() => {
  return canSendMessages.value && messageText.value.trim().length > 0 && !isSending.value
})

const showSenderNames = computed(() => {
  return props.contextType !== 'direct'
})

// Methods
const getMessagesContainerStyle = () => {
  if (props.mode === 'inline') {
    return `height: calc(${props.height} - 120px); overflow-y: auto;`
  }
  if (props.mode === 'mobile') {
    return 'flex: 1; overflow-y: auto;'
  }
  return 'flex: 1; overflow-y: auto; max-height: calc(80vh - 200px);'
}

const getImageStyle = () => {
  const maxWidth = props.mode === 'mobile' ? '100%' : '300px'
  return `max-width: ${maxWidth}; border-radius: 8px;`
}

const getMessageClass = (message: Message) => {
  return {
    'own-message-item': message.isOwn,
    'other-message-item': !message.isOwn,
    'q-mb-sm': props.mode === 'mobile',
    'q-mb-md': props.mode !== 'mobile'
  }
}

const getInputPlaceholder = () => {
  if (!canSendMessages.value) return 'You cannot send messages in this chat'
  return 'Type a message...'
}

const getSenderColor = (senderId: string): string => {
  const index = senderId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)
  const isDarkMode = quasar.dark.isActive
  const colors = isDarkMode ? senderColors.dark : senderColors.light
  return colors[index % colors.length]
}

const cleanDisplayName = (displayName: string, userId: string): string => {
  // Remove Matrix ID from display name if it's included
  // Pattern: "Name (@user:server.com)" or "Name (user:server.com)"
  const escapedUserId = userId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  const patterns = [
    `\\s*\\(${escapedUserId}\\)\\s*`, // Exact match in parentheses
    `\\s*\\(@?${escapedUserId.replace('@', '')}\\)\\s*` // With or without @ in parentheses
  ]

  let cleaned = displayName
  for (const pattern of patterns) {
    cleaned = cleaned.replace(new RegExp(pattern, 'g'), '').trim()
  }

  return cleaned || displayName // Return original if cleaning results in empty string
}

const getRoomStatusText = (): string => {
  if (!isConnected.value) {
    // Check if we're rate limited
    if (rateLimitCountdown.value > 0) {
      const remainingMinutes = Math.ceil(rateLimitCountdown.value / 60000)
      const remainingSeconds = Math.ceil((rateLimitCountdown.value % 60000) / 1000)
      if (remainingMinutes > 1) {
        return `Rate limited - try again in ${remainingMinutes} min`
      } else {
        return `Rate limited - try again in ${remainingSeconds}s`
      }
    }
    return 'Matrix chat unavailable'
  }

  const count = messages.value.length
  switch (props.contextType) {
    case 'direct': return isConnected.value ? 'Online' : 'Offline'
    case 'group': return `${count} messages`
    case 'event': return isConnected.value ? `${count} messages` : 'Not connected'
    default: return ''
  }
}

const isRateLimited = (): boolean => {
  return rateLimitCountdown.value > 0
}

const getConnectButtonLabel = (): string => {
  if (rateLimitCountdown.value > 0) {
    const remainingMinutes = Math.ceil(rateLimitCountdown.value / 60000)
    const remainingSeconds = Math.ceil((rateLimitCountdown.value % 60000) / 1000)
    if (remainingMinutes > 1) {
      return `Try again in ${remainingMinutes} min`
    } else {
      return `Try again in ${remainingSeconds}s`
    }
  }

  // Check if this is a first-time setup
  const needsSetup = !matrixClientService.hasUserChosenToConnect() ||
                     matrixClientService.needsEncryptionSetup?.() || false

  return needsSetup ? 'Set Up Secure Chat' : 'Connect'
}

const hasOidcConfigError = (): boolean => {
  return lastAuthError.value.includes('OIDC authentication is not configured') ||
         lastAuthError.value.includes('404')
}

const formatMessageText = (text: string): string => {
  // Guard against undefined/null text
  if (!text || typeof text !== 'string') {
    logger.warn('formatMessageText called with invalid text:', text)
    return ''
  }

  // Enhanced markdown and URL formatting
  return text
    // Convert URLs to clickable links (must be first to avoid conflicts)
    .replace(/(https?:\/\/[^\s<>"{}|\\^`[\]]+)/gi, '<a href="$1" target="_blank" rel="noopener noreferrer" class="message-link">$1</a>')
    // Bold text: **text**
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    // Italic text: *text* (but not inside URLs or already processed bold)
    .replace(/(?<!\*)\*([^*\s][^*]*[^*\s]|\S)\*(?!\*)/g, '<em>$1</em>')
    // Inline code: `code`
    .replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>')
    // Strikethrough: ~~text~~
    .replace(/~~(.*?)~~/g, '<del>$1</del>')
    // Line breaks: convert \n to <br>
    .replace(/\n/g, '<br>')
}

const formatTime = (date: Date): string => {
  const now = new Date()
  const diff = now.getTime() - date.getTime()

  if (diff < 60000) return 'now'
  if (diff < 3600000) return format(date, 'HH:mm')
  if (diff < 86400000) return format(date, 'HH:mm')
  return format(date, 'MMM d, HH:mm')
}

// Check if message actions should be shown (for own messages or admins)
const shouldShowMessageActions = (message: Message): boolean => {
  // Always show for own messages
  if (message.isOwn) return true

  // Show for users who can delete messages (admins with proper power levels)
  return canDeleteMessage(message)
}

// Check if current user can delete a message
const canDeleteMessage = (message: Message): boolean => {
  if (!message.id || message.id.includes('welcome')) return false

  // Can always delete your own messages
  if (message.isOwn) return true

  // Check Matrix room permissions for moderation capabilities
  const room = currentRoom.value
  const currentUserId = matrixClientService.getClient()?.getUserId()

  if (!room || !currentUserId) {
    // Cannot delete message: no room or user ID
    return false
  }

  // Get current user's power level
  const powerLevels = room.currentState.getStateEvents('m.room.power_levels', '')
  if (!powerLevels) {
    // No power levels found in room
    return false
  }

  const content = powerLevels.getContent()
  const userPowerLevel = content.users?.[currentUserId] ?? content.users_default ?? 0
  const redactLevel = content.redact ?? 50 // Default redact level is 50

  // Can delete if user has sufficient power level
  return userPowerLevel >= redactLevel
}

// Delete/redact a message
const deleteMessage = async (message: Message) => {
  if (!message.id || !canDeleteMessage(message)) return

  // Check if Matrix client is properly authenticated before attempting delete
  const client = matrixClientService.getClient()
  if (!client) {
    quasar.notify({
      type: 'warning',
      message: 'Chat connection not available. Please refresh the page.',
      position: 'top'
    })
    return
  }

  try {
    // Show confirmation dialog
    const confirm = await new Promise<boolean>((resolve) => {
      quasar.dialog({
        title: 'Delete Message',
        message: message.isOwn
          ? 'Are you sure you want to delete this message?'
          : 'Are you sure you want to delete this message? This action cannot be undone.',
        cancel: true,
        persistent: true
      }).onOk(() => resolve(true))
        .onCancel(() => resolve(false))
    })

    if (!confirm) return

    // Deleting message

    // Optimistically remove the message from UI for better UX
    const originalMessages = [...messages.value]
    messages.value = messages.value.filter(msg => msg.id !== message.id)

    try {
      await matrixClientService.redactMessage(props.roomId, message.id)
      // Message deleted successfully

      // Show success feedback
      quasar.notify({
        type: 'positive',
        message: 'Message deleted',
        position: 'top',
        timeout: 2000
      })
    } catch (error) {
      // If deletion fails, restore the message
      messages.value = originalMessages
      throw error
    }
  } catch (error) {
    logger.error('Failed to delete message:', error)

    // Provide more specific error messages
    let errorMessage = 'Failed to delete message'
    if (error.message?.includes('401') || error.message?.includes('Unauthorized')) {
      errorMessage = 'Authentication failed. Please refresh the page and try again.'
    } else if (error.message?.includes('403') || error.message?.includes('Forbidden')) {
      errorMessage = 'You do not have permission to delete this message.'
    }

    quasar.notify({
      type: 'negative',
      message: errorMessage,
      position: 'top',
      timeout: 4000
    })
  }
}

const formatFileSize = (bytes?: number): string => {
  if (!bytes) return 'Unknown size'
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  if (bytes === 0) return '0 Bytes'
  const i = Math.floor(Math.log(bytes) / Math.log(1024))
  return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i]
}

const formatTypingUsers = (users: { userId: string, userName: string }[]): string => {
  if (users.length === 0) return ''
  if (users.length === 1) return `${users[0].userName} is typing...`
  if (users.length === 2) return `${users[0].userName} and ${users[1].userName} are typing...`
  return `${users.length} people are typing...`
}

const getFileIcon = (mimetype?: string): string => {
  if (!mimetype) return 'sym_r_attach_file'
  if (mimetype.startsWith('image/')) return 'sym_r_image'
  if (mimetype.startsWith('video/')) return 'sym_r_videocam'
  if (mimetype.startsWith('audio/')) return 'sym_r_audiotrack'
  if (mimetype.includes('pdf')) return 'sym_r_picture_as_pdf'
  if (mimetype.includes('zip') || mimetype.includes('rar')) return 'sym_r_archive'
  return 'sym_r_attach_file'
}

const getFileUrl = (url: string): string => {
  if (!url) {
    logger.warn('getFileUrl: Empty URL provided')
    return ''
  }

  // If it's already an HTTP URL, return as-is
  if (url.startsWith('http://') || url.startsWith('https://')) {
    // Using HTTP URL as-is
    return url
  }

  // Handle Matrix content URLs (mxc://) for file downloads
  if (url.startsWith('mxc://')) {
    const client = matrixClientService.getClient()
    if (!client) {
      logger.error('getFileUrl: Matrix client not available')
      return ''
    }

    // For files, use download endpoint without dimensions
    const convertedUrl = matrixClientService.getContentUrl(url)
    // Converting Matrix URL for file download

    if (!convertedUrl || convertedUrl === url || !convertedUrl.startsWith('http')) {
      logger.error('getFileUrl: Matrix URL conversion failed or invalid')
      return ''
    }

    return convertedUrl
  }

  // Fallback - return original URL
  // Using original URL
  return url
}

// Load authenticated images and create blob URLs
const loadAuthenticatedImage = async (message: Message): Promise<void> => {
  if (!message.content?.url || message.imageBlobUrl) return

  try {
    const client = matrixClientService.getClient()
    const accessToken = client?.getAccessToken()

    if (!accessToken) {
      logger.error('No access token for image loading')
      return
    }

    // Get thumbnail URL for timeline display (300x300)
    const thumbnailUrl = matrixClientService.getContentUrl(message.content.url, 300, 300)

    // Get full-size URL for modal display
    const fullSizeUrl = matrixClientService.getContentUrl(message.content.url)

    // Load thumbnail image
    const thumbnailResponse = await fetch(thumbnailUrl, {
      headers: { Authorization: `Bearer ${accessToken}` }
    })

    if (thumbnailResponse.ok) {
      const thumbnailBlob = await thumbnailResponse.blob()
      message.imageBlobUrl = URL.createObjectURL(thumbnailBlob)
    }

    // Load full-size image for modal
    if (thumbnailUrl !== fullSizeUrl) {
      const fullSizeResponse = await fetch(fullSizeUrl, {
        headers: { Authorization: `Bearer ${accessToken}` }
      })

      if (fullSizeResponse.ok) {
        const fullSizeBlob = await fullSizeResponse.blob()
        message.fullImageBlobUrl = URL.createObjectURL(fullSizeBlob)
      }
    } else {
      message.fullImageBlobUrl = message.imageBlobUrl
    }
  } catch (error) {
    logger.error('Failed to load authenticated image:', error)
  }
}

const getMessageStatusIcon = (status?: string): string => {
  switch (status) {
    case 'sending': return 'schedule'
    case 'sent': return 'sym_r_done'
    case 'delivered': return 'sym_r_done_all'
    case 'read': return 'sym_r_done_all'
    case 'failed': return 'fas fa-exclamation-triangle'
    default: return 'sym_r_done'
  }
}

const getMessageStatusColor = (status?: string): string => {
  switch (status) {
    case 'sending': return 'grey-6'
    case 'sent': return 'white'
    case 'delivered': return 'green'
    case 'read': return 'green'
    case 'failed': return 'negative'
    default: return 'white'
  }
}

const sendMessage = async () => {
  if (!canSendMessage.value) return

  const text = messageText.value.trim()
  if (!text) return

  isSending.value = true

  try {
    // Clear message input immediately
    messageText.value = ''

    // Focus the input field after sending message
    await nextTick()
    messageInput.value?.$el?.querySelector('input')?.focus()

    // Send message via Matrix client directly - let Matrix SDK handle optimistic rendering
    const roomId = currentRoom.value?.roomId
    if (roomId) {
      await matrixClientService.sendMessage(roomId, {
        body: text,
        msgtype: 'm.text'
      })
    } else {
      console.error('❌ No Matrix room ID available for sending message')
      throw new Error('No Matrix room ID available')
    }

    // Stop typing indicator when message is sent
    await stopTyping()
  } catch (error) {
    console.error('❌ Failed to send message:', error)
    // Show error to user but don't manipulate messages array
    quasar.notify({
      type: 'negative',
      message: 'Failed to send message: ' + (error instanceof Error ? error.message : 'Unknown error'),
      timeout: 3000
    })

    // Put the text back in the input if sending failed
    messageText.value = text
  } finally {
    isSending.value = false
  }
}

const triggerFileUpload = () => {
  fileInput.value?.$el?.querySelector('input')?.click()
}

// Removed unused handleFileUpload function in Phase 2

const addEmoji = (emoji: string) => {
  messageText.value += emoji
  showEmojiPicker.value = false
}

// Show chat help dialog
const showChatHelp = () => {
  // Get the homeserver URL from environment
  const homeserverUrl = getEnv('MATRIX_HOMESERVER_URL')

  quasar.dialog({
    title: 'Chat Help - Use Other Matrix Clients',
    message: `
      <div style="text-align: left;">
        <p><strong>Did you know?</strong> You can use other Matrix clients to access this chat from your phone or computer:</p>

        <p><strong>Mobile Apps:</strong></p>
        <ul>
          <li><strong>Element:</strong> Available on iOS and Android app stores</li>
          <li><strong>FluffyChat:</strong> Alternative client for mobile</li>
          <li><strong>SchildiChat:</strong> Enhanced Element fork</li>
        </ul>

        <p><strong>Desktop Apps:</strong></p>
        <ul>
          <li><strong>Element Desktop:</strong> Available for Windows, Mac, and Linux</li>
          <li><strong>Nheko:</strong> Lightweight desktop client</li>
        </ul>

        <p><strong>How to connect:</strong></p>
        <ol>
          <li>Download and install any Matrix/Element client</li>
          <li><strong>Set the homeserver to:</strong> <code style="background: #f5f5f5; padding: 2px 4px; border-radius: 3px;">${homeserverUrl}</code></li>
          <li><strong>Sign in using your OpenMeet credentials</strong> (same username/email and password you use for OpenMeet)</li>
          <li>Look for your event/group chatrooms in the room list</li>
        </ol>

        <p><em>Your messages will sync across all clients!</em></p>
        <p><small><strong>Note:</strong> Make sure to use the correct homeserver URL above - this connects you to OpenMeet's Matrix server.</small></p>
      </div>
    `,
    html: true,
    ok: 'Got it',
    class: 'chat-help-dialog'
  })
}

// Room joining is now handled in the unified reconnect function

// Typing indicator state
const isTyping = ref(false)
const typingTimer = ref<number | null>(null)

const handleTyping = async () => {
  const roomId = currentRoom.value?.roomId
  if (!isConnected.value || !roomId) return

  try {
    // Only send typing if we weren't already typing
    if (!isTyping.value) {
      await matrixClientService.sendTyping(roomId, true, 10000) // 10 second timeout
      isTyping.value = true
      // Started typing indicator
    }

    // Clear existing timer
    if (typingTimer.value) {
      clearTimeout(typingTimer.value)
    }

    // Set timer to stop typing after 3 seconds of inactivity
    typingTimer.value = window.setTimeout(async () => {
      await stopTyping()
    }, 3000)
  } catch (error) {
    console.warn('⚠️ Failed to send typing indicator:', error)
  }
}

const stopTyping = async () => {
  const roomId = currentRoom.value?.roomId
  if (!isConnected.value || !roomId || !isTyping.value) return

  try {
    await matrixClientService.sendTyping(roomId, false)
    isTyping.value = false
    // Stopped typing indicator

    // Clear timer
    if (typingTimer.value) {
      clearTimeout(typingTimer.value)
      typingTimer.value = null
    }
  } catch (error) {
    console.warn('⚠️ Failed to stop typing indicator:', error)
  }
}

const showImageModal = (src: string) => {
  imageModalSrc.value = src
  imageModal.value = true
}

const downloadFile = async (url: string, filename: string) => {
  try {
    // Starting file download

    // Get Matrix access token for direct authentication (Element Web approach)
    const client = matrixClientService.getClient()
    const accessToken = client?.getAccessToken()

    if (!accessToken) {
      throw new Error('No Matrix access token available')
    }

    // Using direct token auth

    // Make authenticated request directly to Matrix server
    const response = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    })

    if (!response.ok) {
      throw new Error(`Download failed: ${response.status} ${response.statusText}`)
    }

    // Get the blob data
    const blob = await response.blob()

    // Create blob URL and download
    const blobUrl = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = blobUrl
    a.download = filename
    a.click()

    // Clean up blob URL
    URL.revokeObjectURL(blobUrl)

    // File download completed
  } catch (error) {
    console.error('❌ File download failed:', error)
    // Fallback to direct link
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    a.click()
  }
}

const previewFile = async (content: { url?: string; filename?: string; mimetype?: string }) => {
  if (!content.url || !content.filename) {
    console.warn('Missing file URL or filename for preview')
    return
  }

  const fileUrl = getFileUrl(content.url)
  // Previewing file

  if (!fileUrl) {
    console.error('❌ Failed to convert file URL for preview')
    return
  }

  try {
    // Get Matrix access token for authenticated preview
    const client = matrixClientService.getClient()
    const accessToken = client?.getAccessToken()

    if (!accessToken) {
      throw new Error('No Matrix access token available')
    }

    // Using authenticated preview for file

    // Fetch file with authentication
    const response = await fetch(fileUrl, {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    })

    if (!response.ok) {
      throw new Error(`Preview failed: ${response.status} ${response.statusText}`)
    }

    // Get the blob data
    const blob = await response.blob()
    const blobUrl = URL.createObjectURL(blob)

    // For images, show in a dialog
    if (content.mimetype?.startsWith('image/')) {
      showImageModal(blobUrl)
      // Clean up blob URL after a delay to allow image to load
      setTimeout(() => URL.revokeObjectURL(blobUrl), 5000)
      return
    }

    // For text files and other previewable content, open in new tab
    window.open(blobUrl, '_blank')

    // Clean up blob URL after a delay
    setTimeout(() => URL.revokeObjectURL(blobUrl), 30000)
  } catch (error) {
    console.error('❌ File preview failed:', error)
    quasar.notify({
      type: 'negative',
      message: 'Failed to preview file: ' + (error instanceof Error ? error.message : 'Unknown error'),
      timeout: 3000
    })
  }
}

const scrollToBottom = async (smooth = false) => {
  await nextTick()
  if (messagesContainer.value) {
    if (smooth) {
      messagesContainer.value.scrollTo({
        top: messagesContainer.value.scrollHeight,
        behavior: 'smooth'
      })
    } else {
      messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
    }
  }
}

const sendReadReceipts = async () => {
  if (!props.roomId || !isConnected.value) return

  try {
    // Find the last message that's not from us
    const lastOtherMessage = messages.value
      .slice()
      .reverse()
      .find(msg => !msg.isOwn && msg.id && !msg.id.includes('welcome'))

    if (lastOtherMessage && lastOtherMessage.id && lastOtherMessage.id !== lastReadReceiptSent.value) {
      const roomId = currentRoom.value?.roomId
      if (roomId) {
        await matrixClientService.sendReadReceipt(roomId, lastOtherMessage.id)
      }
      lastReadReceiptSent.value = lastOtherMessage.id
    }
  } catch (error) {
    console.warn('⚠️ Failed to send read receipt:', error)
  }
}

const updateReadReceipts = async () => {
  // Update read receipts called
  if (!props.roomId || !isConnected.value) return

  try {
    // Update read receipts for all messages
    const currentUserId = matrixClientService.getClient()?.getUserId()
    if (!currentUserId) return

    const room = currentRoom.value
    if (!room) return

    // Optimization: Only process recent messages (last 30) to avoid performance issues
    const recentMessages = messages.value.slice(-30)
    const recentMessageIds = recentMessages.map(m => m.id).filter(Boolean)

    // Processing read receipts for recent messages

    // Get all other users in the room (exclude current user)
    const otherUsers = room.getMembers()
      .filter(member => member.userId !== currentUserId)

    // Processing room members for read receipts

    // Build a cache of all receipt data in one pass
    const receiptCache = new Map<string, Array<{ userId: string, timestamp: number }>>()

    for (const messageId of recentMessageIds) {
      if (messageId && !messageId.includes('welcome')) {
        const receipts = matrixClientService.getReadReceipts(props.roomId, messageId)
        receiptCache.set(messageId, receipts)

        if (receipts.length > 0) {
          // Message has read receipts
        }
      }
    }

    // Find the latest read position for each user using cached data
    const userReadPositions = new Map<string, { eventId: string, messageIndex: number }>()

    for (const member of otherUsers) {
      const userId = member.userId
      let latestReadEventId: string | null = null
      let latestTimestamp = 0
      let messageIndex = -1

      // Check cached receipts to find this user's latest read message
      for (let i = 0; i < recentMessages.length; i++) {
        const message = recentMessages[i]
        if (!message.id) continue

        const receipts = receiptCache.get(message.id) || []
        const userReceipt = receipts.find(r => r.userId === userId)

        if (userReceipt && userReceipt.timestamp > latestTimestamp) {
          latestTimestamp = userReceipt.timestamp
          latestReadEventId = message.id
          messageIndex = i
        }
      }

      if (latestReadEventId && messageIndex >= 0) {
        userReadPositions.set(userId, { eventId: latestReadEventId, messageIndex })
      }
    }

    // User read positions calculated

    // Debug: Show which users have NO read receipts
    const usersWithoutReceipts = otherUsers.filter(member => !userReadPositions.has(member.userId))
    if (usersWithoutReceipts.length > 0) {
      // Some users have no read receipts
    }

    // Apply read receipts to recent messages only
    for (let i = 0; i < recentMessages.length; i++) {
      const message = recentMessages[i]
      if (!message.id || message.id.includes('welcome')) continue

      const messageReadBy: Array<{ userId: string, userName: string, timestamp: number }> = []

      // Check if each user has read this message (if they read this message or any later message)
      for (const [userId, readPosition] of Array.from(userReadPositions.entries())) {
        if (readPosition.messageIndex >= i) {
          const member = room.getMember(userId)
          messageReadBy.push({
            userId,
            userName: member?.name || member?.rawDisplayName || userId.split(':')[0].substring(1) || 'Unknown',
            timestamp: Date.now()
          })
        }
      }

      message.readReceipts = messageReadBy
      if (messageReadBy.length > 0) {
        // Message read by users
      }
    }

    // Clear read receipts for older messages to save memory
    const olderMessages = messages.value.slice(0, -30)
    for (const message of olderMessages) {
      message.readReceipts = []
    }
  } catch (error) {
    console.warn('⚠️ Failed to update read receipts:', error)
  }
}

const reconnect = async () => {
  isConnecting.value = true

  try {
    // Attempting to reconnect Matrix client

    // First try to refresh the Matrix token
    try {
      await matrixClientManager.refreshMatrixToken()
      // Matrix token refreshed successfully
    } catch (tokenError) {
      console.warn('⚠️ Token refresh failed, continuing with existing token:', tokenError)
    }

    // Check if Matrix client is already available and just needs to reconnect
    if (matrixClientService.isReady()) {
      // Matrix client already ready
      roomName.value = props.contextType === 'event' ? 'Event Chatroom' : props.contextType === 'group' ? 'Group Chatroom' : `${props.contextType} Chat`

      // Reload messages if we have a room ID
      if (props.roomId) {
        await loadMessages()
        await scrollToBottom()
      }
      return
    }

    // Check if this is a first-time setup and redirect to setup flow if needed
    const needsSetup = !matrixClientService.hasUserChosenToConnect() ||
                       matrixClientService.needsEncryptionSetup?.() || false

    if (needsSetup) {
      // For first-time users, redirect to the setup flow via window navigation
      // This ensures they go through the proper education and encryption setup
      const currentPath = window.location.pathname + window.location.search
      const setupUrl = `/dashboard/chats?chat=${encodeURIComponent(props.roomId || props.contextId || 'setup')}&return=${encodeURIComponent(currentPath)}`

      console.log('🔄 Redirecting to setup flow:', setupUrl)
      window.location.href = setupUrl
      return
    }

    // Try to connect to Matrix client (this will handle authentication)
    await matrixClientService.connectToMatrix()
    // Matrix client connected successfully

    // After successful Matrix connection, ensure we're invited to the chat room
    if (props.contextType === 'event' && props.contextId) {
      try {
        // Joining event chat room
        const result = await matrixClientService.joinEventChatRoom(props.contextId)
        // Event chat room joined successfully
        // Force Matrix client to sync to pick up new invitation
        await matrixClientService.forceSyncAfterInvitation('event', props.contextId)
        // Update current room to use the actual room ID from join result
        if (result.room?.roomId) {
          // Using actual room ID from join result
          currentRoom.value = result.room
          // Load messages with the correct room ID
          await loadMessages()
        } else {
          // Fallback: update current room state and load messages
          await updateCurrentRoom()
          await loadMessages()
        }
      } catch (error) {
        console.error('❌ EXCEPTION: Failed to join event chat room')
        console.error('❌ Error details:', error)
        console.error('❌ Error message:', error.message)

        // Check if this is a Matrix authentication requirement error
        const errorMessage = error.message || ''
        if (errorMessage.includes('has not authenticated with Matrix') ||
            errorMessage.includes('must complete Matrix authentication')) {
          // User needs Matrix authentication
          // Don't throw - this is a normal flow that requires authentication
        } else {
          // Other errors - log but don't break the connection
          console.warn('⚠️ Non-authentication error joining event chat room')
        }
      }
    }

    if (props.contextType === 'group' && props.contextId) {
      try {
        // Joining group chat room
        const result = await matrixClientService.joinGroupChatRoom(props.contextId)
        // Group chat room joined successfully
        // Force Matrix client to sync to pick up new invitation
        await matrixClientService.forceSyncAfterInvitation('group', props.contextId)
        // Update current room to use the actual room ID from join result
        if (result.room?.roomId) {
          // Using actual room ID from join result
          currentRoom.value = result.room
          // Load messages with the correct room ID
          await loadMessages()
        } else {
          // Fallback: update current room state and load messages
          await updateCurrentRoom()
          await loadMessages()
        }
      } catch (error) {
        console.warn('⚠️ Failed to join group chat room (continuing anyway):', error)
        // Don't throw - connection to Matrix itself succeeded
      }
    }

    lastAuthError.value = '' // Clear any previous errors
    roomName.value = `${props.contextType} Chat`

    // Reload messages if we have a room ID
    if (props.roomId) {
      await loadMessages()
      await scrollToBottom()
    }
  } catch (error: unknown) {
    console.error('❌ Failed to connect Matrix client:', error)

    // Check for rate limiting error - handle both object and nested error formats
    const errorObj = (error as Record<string, unknown>)
    const nestedError = errorObj.errcode ? errorObj : (errorObj.data || errorObj)
    const errorMessage = (error as Error).message

    if ((nestedError as Record<string, unknown>).errcode === 'M_LIMIT_EXCEEDED' || (errorMessage && errorMessage.includes('Too Many Requests'))) {
      // FIRST: Check if rate limit was already set by Matrix client service (most reliable)
      const existingRetryTime = window.matrixRetryAfter
      console.warn('🔍 Rate limit detected - checking existing timer:', {
        existingRetryTime,
        currentTime: Date.now(),
        hasValidExisting: !!(existingRetryTime && existingRetryTime > Date.now())
      })

      if (existingRetryTime && existingRetryTime > Date.now()) {
        // Use the existing rate limit set by Matrix client service
        const remainingMs = existingRetryTime - Date.now()
        const remainingSeconds = Math.ceil(remainingMs / 1000)
        console.warn(`⚠️ Using Matrix client service rate limit - retry in ${remainingSeconds} seconds (${remainingMs}ms remaining)`)
        rateLimitCountdown.value = remainingMs
        startCountdownTimer()
      } else {
        // Fallback: try to extract retry_after_ms from the error
        let retryAfterMs = (nestedError as Record<string, unknown>).retry_after_ms as number

        // Check alternative locations for retry time
        if (!retryAfterMs) {
          retryAfterMs = (nestedError as Record<string, unknown>).retry_after as number
        }
        if (!retryAfterMs && (errorObj as { retry_after_ms?: number }).retry_after_ms) {
          retryAfterMs = (errorObj as { retry_after_ms?: number }).retry_after_ms
        }
        if (!retryAfterMs && (errorObj as { data?: { retry_after_ms?: number } }).data?.retry_after_ms) {
          retryAfterMs = (errorObj as { data?: { retry_after_ms?: number } }).data.retry_after_ms
        }

        if (retryAfterMs && retryAfterMs > 0) {
          const retryAfterSeconds = Math.ceil(retryAfterMs / 1000)
          console.warn(`⚠️ Rate limited - extracted from error, retry in ${retryAfterSeconds} seconds (${retryAfterMs}ms)`)
          window.matrixRetryAfter = Date.now() + retryAfterMs
          rateLimitCountdown.value = retryAfterMs
          startCountdownTimer()
        } else {
          console.warn('⚠️ Rate limited - no retry time found anywhere, using 5 minute default')
          window.matrixRetryAfter = Date.now() + 300000 // Default to 5 minutes
          rateLimitCountdown.value = 300000
          startCountdownTimer()
        }
      }
    } else if (errorMessage && errorMessage.includes('OIDC authentication is not configured')) {
      console.warn('⚠️ Matrix OIDC is not configured on the server')
      lastAuthError.value = errorMessage
    } else if (errorMessage && errorMessage.includes('login token')) {
      console.warn('⚠️ Authentication failed - please refresh the page to re-authenticate')
      lastAuthError.value = errorMessage
    } else if (errorMessage && errorMessage.includes('credentials expired')) {
      console.warn('⚠️ Session expired - please refresh the page to re-authenticate')
      lastAuthError.value = errorMessage
    }
  } finally {
    isConnecting.value = false
  }
}

const clearMatrixSessions = async () => {
  try {
    // User requested Matrix session clearing

    // Show confirmation dialog
    const confirmed = confirm(
      'This will clear all Matrix sessions and require you to sign in again. ' +
      'This can help fix authentication and message history issues. Continue?'
    )

    if (!confirmed) {
      return
    }

    // Clear all Matrix data including encryption keys via service
    await matrixClientService.clearAllMatrixData()

    // Reset component state
    isConnecting.value = false
    messages.value = []

    // Matrix sessions cleared
    alert('Matrix sessions cleared successfully! Please refresh the page to sign in again.')
  } catch (error) {
    console.error('❌ Failed to clear Matrix sessions:', error)
    alert('Failed to clear Matrix sessions. Please try again or contact support.')
  }
}

// Removed unused recreateEventRoom and recreateGroupRoom functions in Phase 2

// Start countdown timer for rate limiting
const startCountdownTimer = () => {
  if (countdownTimer.value) {
    clearInterval(countdownTimer.value)
  }

  countdownTimer.value = setInterval(() => {
    if (rateLimitCountdown.value > 0) {
      rateLimitCountdown.value -= 1000
    } else {
      clearInterval(countdownTimer.value!)
      countdownTimer.value = null
    }
  }, 1000)
}

// Load older messages with pagination
const loadOlderMessages = async () => {
  if (isLoadingOlderMessages.value || !hasMoreHistory.value) {
    // Already loading older messages or no more history
    return
  }

  // Loading older messages with increased limit
  isLoadingOlderMessages.value = true

  try {
    const previousMessageCount = messages.value.length
    const newLimit = currentHistoryLimit.value + 25 // Load 25 more messages

    // Loading room history with increased limit

    // Skip waitForRoomReady if sync is stuck - try to get room directly
    const client = matrixClientService.getClient()
    if (!client) {
      console.warn('⚠️ No Matrix client available')
      return
    }

    const room = currentRoom.value
    if (!room) {
      console.warn('⚠️ Room not available for loading older messages:', props.roomId)
      // Available rooms checked
      return
    }

    // Got room directly

    // Use the loadRoomHistory method with increased limit
    const events = await matrixClientService.loadRoomHistory(props.roomId, newLimit)

    if (events.length === 0) {
      // No messages found in room history
      hasMoreHistory.value = false
      return
    }

    // Convert Matrix events to our Message format
    const formattedMessages = events.map(event => {
      const content = event.getContent()
      const sender = event.getSender()
      const senderName = event.sender?.name || sender || 'Unknown'
      const currentUser = matrixClientService.getClient()?.getUserId()

      return {
        id: event.getId() || `${event.getTs()}-${sender}`,
        type: content.msgtype === 'm.image' ? 'image' as const : 'text' as const,
        sender: {
          id: sender || 'unknown',
          name: senderName,
          avatar: event.sender?.getAvatarUrl(matrixClientService.getClient()?.baseUrl || '', 32, 32, 'crop', false, false) || undefined
        },
        content: {
          body: content.body || '',
          url: content.url,
          filename: content.body,
          mimetype: content.info?.mimetype,
          size: content.info?.size
        },
        timestamp: new Date(event.getTs()),
        isOwn: sender === currentUser,
        status: 'sent' as const
      }
    })

    messages.value = formattedMessages
    currentHistoryLimit.value = newLimit

    // Check if we loaded new messages
    if (formattedMessages.length === previousMessageCount) {
      // No new messages loaded - reached end of history
      hasMoreHistory.value = false
    } else {
      // Loaded new older messages
    }
  } catch (error) {
    console.error('❌ Failed to load older messages:', error)
  } finally {
    isLoadingOlderMessages.value = false
  }
}

// Prevent duplicate loading
const isLoading = ref(false)

/**
 * Handle crypto events for timeline refresh (Element Web pattern)
 */
const onKeyBackupStatus = (enabled: boolean) => {
  logger.debug(`🔑 Key backup status changed: ${enabled} - refreshing timeline`)
  // Element Web calls forceUpdate(), we reload messages
  if (enabled && messages.value.length > 0) {
    loadMessages().catch(error => logger.error('Failed to refresh after backup status change:', error))
  }
}

const onEventDecrypted = (event: MatrixEvent) => {
  logger.debug(`🔓 Event decrypted: ${event.getId()} - checking if timeline refresh needed`)
  // If the decrypted event is in current room, we might want to refresh
  if (event.getRoomId() === props.roomId && !event.isDecryptionFailure()) {
    // Element Web doesn't reload timeline here, but our messages might need updating
    // Only refresh if we have encrypted messages that might now be decryptable
    logger.debug('✅ Event successfully decrypted for current room')
  }
}

const onKeysChanged = () => {
  logger.debug('🔑 Cross-signing keys changed - checking if timeline refresh needed')
  // This could indicate successful key restore, refresh if we have messages
  if (messages.value.length > 0) {
    loadMessages().catch(error => logger.error('Failed to refresh after keys changed:', error))
  }
}

const loadMessages = async () => {
  if (isLoading.value) {
    // Already loading messages, skipping duplicate call
    return
  }

  // Starting loadMessages
  // Current Matrix client sync state checked
  isLoading.value = true

  // Clear messages immediately when switching rooms for better UX
  messages.value = []

  try {
    // Loading messages with Element-web pattern

    // Element-web pattern: Work with SYNCING state, don't wait for PREPARED
    const client = matrixClientService.getClient()
    if (!client) {
      console.warn('⚠️ No Matrix client available')
      return
    }

    const syncState = client.getSyncState()
    // Matrix client sync state checked

    // Be more lenient with sync states - sometimes the client works even when not in perfect state
    const workingStates = ['SYNCING', 'PREPARED', 'CATCHUP', 'RECONNECTING', 'STOPPED']

    // Handle null syncState more gracefully
    if (syncState === null) {
      logger.debug('⚠️ Matrix client sync state is null - client may still be initializing')
      // Don't return early - try to load messages anyway as client may still work
    } else if (!workingStates.includes(syncState)) {
      console.warn(`⚠️ Matrix client not in working state: ${syncState}, but attempting to proceed anyway`)
      // Don't return early - try to load messages anyway
    }

    // Get room directly without waiting for PREPARED state
    const room = currentRoom.value
    if (!room) {
      // console.warn('⚠️ Room not available:', props.roomId)
      // client.getRooms()
      // Available rooms checked
      // Expected room not found, attempting to join

      // Try to join the room if it's not available
      try {
        // Attempting to join room
        await client.joinRoom(props.roomId)
        // Successfully joined room
        // Give it a moment to sync
        await new Promise(resolve => setTimeout(resolve, 1000))
      } catch (joinError) {
        console.warn('⚠️ Failed to join room:', joinError)
        return
      }
    }

    // Get the room again (might be newly joined)
    const finalRoom = currentRoom.value
    if (!finalRoom) {
      console.error('❌ Still no room available after join attempt:', props.roomId)
      return
    }

    // Room available, proceeding with message loading
    // Room member count checked

    // Load historical messages using the robust pagination method from matrixClientService
    // Loading historical messages with pagination
    let events: MatrixEvent[] = []

    // Always attempt to load historical messages to ensure history is visible
    // Loading historical messages to ensure history shown
    try {
      // Use the service's loadRoomHistory method which handles proper pagination
      // Load at least 20 messages initially to ensure we have history to show
      const initialLoad = 20
      const roomId = currentRoom.value?.roomId || props.roomId
      events = await matrixClientService.loadRoomHistory(roomId, initialLoad)
      // Loaded historical messages via pagination

      // If we got messages, update hasMoreHistory flag
      if (events.length > 0) {
        hasMoreHistory.value = true
        // Historical messages loaded successfully
      } else {
        // No historical messages loaded via pagination
      }
    } catch (error) {
      console.warn('⚠️ Failed to load historical messages via pagination, falling back to timeline:', error)
      // Fallback - try direct timeline access
      const timeline = finalRoom.getLiveTimeline()
      const timelineEvents = timeline.getEvents().filter(event => {
        const eventType = event.getType()
        return eventType === 'm.room.message' || eventType === 'm.room.encrypted'
      })
      events = timelineEvents
      // Fallback: events from current timeline
    }

    const currentUserId = matrixClientService.getClient()?.getUserId()
    const roomMessages = events
      .map(event => {
        const senderId = event.getSender()
        const member = finalRoom?.getMember(senderId)
        // For encrypted events, get the decrypted content if available
        const eventType = event.getType()
        const content = eventType === 'm.room.encrypted'
          ? (event.getClearContent() || event.getContent())
          : event.getContent()
        const msgtype = content.msgtype

        return {
          id: event.getId(),
          type: (msgtype === 'm.image' ? 'image' : msgtype === 'm.file' ? 'file' : 'text') as 'text' | 'image' | 'file',
          sender: {
            id: senderId,
            name: member?.name || member?.rawDisplayName || senderId.split(':')[0].substring(1) || 'Unknown',
            avatar: member?.getAvatarUrl?.(matrixClientService.getClient()?.baseUrl || '', 32, 32, 'crop', false, false) || undefined
          },
          content: {
            body: content.body || (eventType === 'm.room.encrypted' ? '🔒 [Unable to decrypt message]' : ''),
            url: content.url,
            filename: content.filename,
            mimetype: content.info?.mimetype,
            size: content.info?.size
          },
          timestamp: new Date(event.getTs()),
          isOwn: senderId === currentUserId,
          status: 'read' as const
        }
      })

    // Set the converted messages to display
    if (roomMessages && roomMessages.length > 0) {
      messages.value = roomMessages.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime())
      messageCount.value = messages.value.length
      logger.debug('✅ Messages loaded and sorted:', {
        totalMessages: messages.value.length,
        ownMessages: messages.value.filter(m => m.isOwn).length,
        otherMessages: messages.value.filter(m => !m.isOwn).length,
        oldestMessage: messages.value[0]?.timestamp,
        newestMessage: messages.value[messages.value.length - 1]?.timestamp
      })

      // Load authenticated images for all image messages
      const imageMessages = messages.value.filter(m => m.type === 'image')
      // Loading authenticated images
      imageMessages.forEach(message => loadAuthenticatedImage(message))
    } else {
      // No messages found after processing

      // For debugging, let's try to get more info about the room
      const roomTimeline = finalRoom.getLiveTimeline()
      logger.debug('🔍 Room debug info:', {
        roomMembers: finalRoom.getJoinedMembers().map(m => ({ id: m.userId, name: m.name })),
        allTimelineEvents: roomTimeline.getEvents().length,
        roomName: finalRoom.name,
        roomTopic: finalRoom.currentState?.getStateEvents('m.room.topic', '')?.getContent()?.topic
      })

      // No messages found - create a welcome message
      messages.value = [{
        id: 'welcome',
        type: 'text',
        sender: {
          id: 'system',
          name: 'System'
        },
        content: {
          body: `Welcome to the ${props.contextType} discussion! Start the conversation by sending a message.`
        },
        timestamp: new Date(),
        isOwn: false,
        status: 'read' as const
      }]
      logger.debug('ℹ️ No messages found, showing welcome message')
    }
  } catch (error) {
    console.error('❌ Failed to load messages:', error)
    messages.value = []
  } finally {
    logger.debug('🏗️ DEBUG: loadMessages() completed, setting isLoading=false')
    isLoading.value = false
  }
}

// Removed unused loadOlderMessages function in Phase 2

// Watchers - only reload when roomId actually changes
watch(() => props.roomId, async (newRoomId, oldRoomId) => {
  if (newRoomId && newRoomId !== oldRoomId) {
    logger.debug('🔄 Room ID changed from', oldRoomId, 'to', newRoomId)
    await loadMessages()
    await scrollToBottom()
  }
})

// Add a retry mechanism for loading messages when sync state changes
const handleSyncStateChange = async (state: string, prevState?: string) => {
  logger.debug('🔄 Matrix sync state changed:', { state, prevState, roomId: props.roomId })

  // Also check for 'SYNCING' state which often precedes room availability
  if ((state === 'PREPARED' || state === 'SYNCING') && props.roomId) {
    // If room resolution failed before, retry now that sync is active
    if (!currentRoom.value) {
      logger.debug('🔄 Sync state active, retrying room resolution for:', props.roomId)
      await updateCurrentRoom()

      // If room was resolved, load messages
      if (currentRoom.value) {
        logger.debug('✅ Room resolved after sync, loading messages')
        await loadMessages()
        await scrollToBottom()
      }
    }

    // If no messages loaded yet and room is available, retry loading them
    if (currentRoom.value && messages.value.length === 0) {
      logger.debug('🔄 Sync active and room available, loading messages')
      await loadMessages()
      await scrollToBottom()
    }
  }
}

// Update message count when messages change
watch(messages, (newMessages) => {
  messageCount.value = newMessages.length
}, { immediate: true })

// Send read receipts when message count or connection state changes
watch([messageCount, isConnected], async ([newCount]) => {
  if (isConnected.value && newCount > 0) {
    // Small delay to ensure messages are rendered
    setTimeout(() => {
      sendReadReceipts()
      updateReadReceipts()
    }, 500)
  }
})

// Track if listeners are already set up to prevent duplicates
let listenersSetUp = false

// Set up Matrix client event listeners
const setupMatrixEventListeners = () => {
  const client = matrixClientService.getClient()
  if (!client) {
    console.warn('⚠️ Matrix client not available for event listeners')
    return
  }

  if (listenersSetUp) {
    logger.debug('✅ Matrix client event listeners already set up, skipping')
    return
  }

  logger.debug('🔌 Setting up Matrix client event listeners')
  listenersSetUp = true

  // Initialize encryption in background for group chats (matches UnifiedChatComponent pattern)
  logger.debug('🔐 Starting background encryption initialization for single-room interface')
  matrixEncryptionService.initializeEncryptionBackground()
    .then(ready => {
      logger.debug(ready ? '✅ Background encryption ready for group chat' : '⚠️ Background encryption not ready')
    })
    .catch(error => {
      logger.warn('⚠️ Background encryption initialization error:', error)
    })

  // Listen for sync state changes to retry room resolution
  client.on(ClientEvent.Sync, handleSyncStateChange)

  // Listen for crypto events to refresh timeline when decryption becomes available (Element Web pattern)
  client.on(CryptoEvent.KeyBackupStatus, onKeyBackupStatus)
  client.on(CryptoEvent.KeysChanged, onKeysChanged)
  client.on(MatrixEventEvent.Decrypted, onEventDecrypted)

  // Listen for live timeline events (new messages) - following Element Web's pattern
  const handleTimelineEvent = async (
    event: MatrixEvent,
    room: Room | undefined,
    toStartOfTimeline: boolean | undefined,
    removed: boolean,
    data: { timeline?: unknown; liveEvent?: boolean }
  ) => {
    // Debug: Log all timeline events to understand filtering
    logger.debug('🔍 Timeline event received:', {
      eventType: event.getType(),
      roomId: room?.roomId,
      currentRoomId: props.roomId,
      toStartOfTimeline,
      dataStructure: data,
      hasRoom: !!room,
      hasData: !!data,
      liveEvent: data?.liveEvent
    })

    // Follow Element Web's filtering pattern exactly

    // ignore events for other rooms - check both room ID and aliases
    if (!room) {
      logger.debug('❌ Filtered: no room')
      return
    }

    const roomId = room.roomId
    const roomAlias = room.getCanonicalAlias() || room.getAltAliases()?.[0]
    const matchesRoom = roomId === props.roomId || roomAlias === props.roomId

    if (!matchesRoom) {
      logger.debug('❌ Filtered: wrong room', {
        eventRoomId: roomId,
        eventRoomAlias: roomAlias,
        currentRoomId: props.roomId,
        matches: matchesRoom
      })
      return
    }

    logger.debug('✅ Room match found:', { eventRoomId: roomId, currentRoomId: props.roomId })

    // ignore events from filtered timelines
    if (data?.timeline && typeof data.timeline === 'object' && 'getTimelineSet' in data.timeline) {
      const timeline = data.timeline as { getTimelineSet(): unknown }
      if (timeline.getTimelineSet() !== room.getUnfilteredTimelineSet()) {
        logger.debug('❌ Filtered: filtered timeline')
        return
      }
    }

    // ignore anything but real-time updates at the end of the room
    if (toStartOfTimeline || !data?.liveEvent) {
      logger.debug('❌ Filtered: not live event', { toStartOfTimeline, liveEvent: data?.liveEvent })
      return
    }

    const eventType = event.getType()
    if (eventType === 'm.room.message' || eventType === 'm.room.encrypted') {
      // Debug encrypted message content extraction
      const rawContent = event.getContent()
      const clearContent = eventType === 'm.room.encrypted' ? event.getClearContent() : null

      logger.debug('📨 Live timeline event (Element Web pattern):', {
        eventId: event.getId(),
        roomId: room.roomId,
        currentRoomId: props.roomId,
        sender: event.getSender(),
        eventType,
        rawContent,
        clearContent,
        timestamp: new Date(event.getTs()).toLocaleTimeString()
      })

      // Instead of reloading all messages, just add this new message

      // For encrypted events, trigger immediate decryption attempt FIRST
      if (eventType === 'm.room.encrypted') {
        const client = matrixClientService.getClient()
        if (client) {
          try {
            // Attempt to decrypt the event immediately - Element-Web pattern
            await client.decryptEventIfNeeded(event)
            logger.debug('✅ Event decrypted successfully for live display')
          } catch (error) {
            logger.warn('⚠️ Failed to decrypt event immediately:', error)
          }
        }
      }

      // AFTER decryption attempt, get the content (decrypted if successful)
      const content = eventType === 'm.room.encrypted'
        ? (event.getClearContent() || event.getContent())
        : event.getContent()
      const senderId = event.getSender()
      const member = room.getMember(senderId || '')

      // Debug the final content being used
      logger.debug('🔍 Message content extraction:', {
        eventType,
        finalContent: content,
        hasBody: !!content?.body,
        bodyContent: content?.body,
        msgtype: content?.msgtype
      })

      // Create the new message object with proper type detection
      const msgtype = content.msgtype || 'm.text'
      const messageType = msgtype === 'm.image' ? 'image' : msgtype === 'm.file' ? 'file' : 'text'

      const newMessage = {
        id: event.getId() || '',
        type: messageType as 'text' | 'image' | 'file',
        sender: {
          id: senderId || '',
          name: member?.name || member?.rawDisplayName || senderId?.split(':')[0].substring(1) || 'Unknown',
          avatar: member?.getAvatarUrl?.(matrixClientService.getClient()?.baseUrl || '', 32, 32, 'crop', false, false) || undefined
        },
        content: messageType === 'text' ? {
          body: content.body || (eventType === 'm.room.encrypted' ? '🔒 [Unable to decrypt message]' : '')
        } : {
          body: content.body || content.filename || (eventType === 'm.room.encrypted' ? '🔒 [Encrypted file]' : ''),
          filename: content.filename,
          url: content.url,
          info: content.info,
          msgtype: content.msgtype
        },
        timestamp: new Date(event.getTs()),
        isOwn: senderId === matrixClientService.getClient()?.getUserId(),
        status: 'read' as const
      }

      logger.debug('📄 Message type detected:', { msgtype, messageType, content })

      // Add to messages array and scroll to bottom smoothly
      messages.value = [...messages.value, newMessage]
      messageCount.value = messages.value.length

      logger.debug('✅ Added new live message to chat:', newMessage.content.body)

      // Load authenticated image for image messages
      if (newMessage.type === 'image') {
        logger.debug('🖼️ Loading authenticated image for new live message:', newMessage.content.filename)
        loadAuthenticatedImage(newMessage)
      }

      // Only scroll if this is not our own message (to avoid disrupting typing)
      if (!newMessage.isOwn) {
        await nextTick()
        await scrollToBottom(true) // smooth scroll for new messages
      }
    }
  }

  client.on(RoomEvent.Timeline, handleTimelineEvent)

  // Handle async decryption events - following Element-Web pattern
  const handleEventDecrypted = async (event: MatrixEvent) => {
    logger.debug('🔓 Event decrypted:', {
      eventId: event.getId(),
      eventType: event.getType(),
      roomId: event.getRoomId(),
      currentRoomId: props.roomId,
      hasDecryptedContent: !!event.getClearContent()?.body
    })

    // Only handle events from our current room
    if (event.getRoomId() !== props.roomId) {
      return
    }

    // Only handle message events
    if (event.getType() !== 'm.room.encrypted') {
      return
    }

    // Find the message in our current messages and update it
    const eventId = event.getId()
    if (!eventId) return

    const messageIndex = messages.value.findIndex(msg => msg.id === eventId)
    if (messageIndex === -1) {
      logger.debug('🔍 Decrypted event not found in current messages, will be handled by next message load')
      return
    }

    logger.debug('🔄 Updating decrypted message content:', {
      messageIndex,
      oldContent: messages.value[messageIndex].content.body,
      eventId
    })

    // Get the decrypted content
    const clearContent = event.getClearContent()
    if (!clearContent?.body) {
      logger.warn('⚠️ Decrypted event has no clear content body')
      return
    }

    // Update the message content with decrypted data
    const updatedMessage = { ...messages.value[messageIndex] }
    updatedMessage.content = {
      ...updatedMessage.content,
      body: clearContent.body,
      msgtype: clearContent.msgtype || 'm.text'
    }

    // Handle different message types after decryption
    if (clearContent.msgtype === 'm.image' && clearContent.url) {
      updatedMessage.type = 'image'
      updatedMessage.content.url = clearContent.url
      updatedMessage.content.mimetype = clearContent.info?.mimetype
      updatedMessage.content.size = clearContent.info?.size
    } else if (clearContent.msgtype === 'm.file' && clearContent.url) {
      updatedMessage.type = 'file'
      updatedMessage.content.url = clearContent.url
      updatedMessage.content.filename = clearContent.filename || clearContent.body
      updatedMessage.content.mimetype = clearContent.info?.mimetype
      updatedMessage.content.size = clearContent.info?.size
    } else {
      updatedMessage.type = 'text'
    }

    // Replace the message in the array
    messages.value[messageIndex] = updatedMessage

    logger.debug('✅ Message updated with decrypted content:', {
      eventId,
      newContent: updatedMessage.content.body,
      newType: updatedMessage.type
    })
  }

  // Listen for decryption events globally
  client.on(MatrixEventEvent.Decrypted, handleEventDecrypted)

  // Store cleanup function for onUnmounted
  onUnmounted(() => {
    if (client) {
      client.off(ClientEvent.Sync, handleSyncStateChange)
      client.off(RoomEvent.Timeline, handleTimelineEvent)
      client.off(MatrixEventEvent.Decrypted, handleEventDecrypted)
    }
  })
}

// Handle file upload when a file is selected
watch(selectedFile, async (newFile) => {
  const roomId = currentRoom.value?.roomId
  logger.debug('🔍 File watcher triggered:', { newFile: newFile?.name, roomId })

  if (!newFile || !roomId) {
    logger.debug('⚠️ File upload cancelled - missing file or room ID')
    return
  }

  logger.debug('📎 Starting file upload process:', {
    fileName: newFile.name,
    fileSize: newFile.size,
    fileType: newFile.type,
    roomId: props.roomId
  })

  isSending.value = true

  try {
    logger.debug('🔄 Checking Matrix client availability...')

    // Check if Matrix client is available
    const client = matrixClientService.getClient()
    logger.debug('🔍 Matrix client check result:', { hasClient: !!client })

    if (!client) {
      console.error('❌ Matrix client not available')
      throw new Error('Matrix client not available - please connect to Matrix first')
    }

    logger.debug('🔑 Matrix client status:', {
      hasClient: !!client,
      isLoggedIn: client.isLoggedIn(),
      userId: client.getUserId(),
      baseUrl: client.getHomeserverUrl()
    })

    // Use the resolved room ID (same as text messages) instead of the room alias
    const roomId = currentRoom.value?.roomId
    if (!roomId) {
      throw new Error('No room ID available for file upload')
    }

    logger.debug('📤 About to call uploadAndSendFile with resolved room ID:', roomId)
    const result = await matrixClientService.uploadAndSendFile(roomId, newFile)
    logger.debug('✅ uploadAndSendFile completed, result:', result)
    logger.debug('✅ File uploaded successfully!')

    // Clear the selected file
    selectedFile.value = null
  } catch (error) {
    console.error('❌ Failed to upload file:', error)
    console.error('❌ Error details:', {
      message: error instanceof Error ? error.message : 'Unknown error',
      stack: error instanceof Error ? error.stack : undefined,
      error
    })

    quasar.notify({
      type: 'negative',
      message: 'Failed to upload file: ' + (error instanceof Error ? error.message : 'Unknown error'),
      timeout: 3000
    })
  } finally {
    isSending.value = false
  }
})

// Auto-scroll when typing indicators appear or disappear
watch(typingUsers, async (newTypingUsers, oldTypingUsers) => {
  logger.debug('🎯 Typing users watcher triggered!', {
    newCount: newTypingUsers.length,
    oldCount: oldTypingUsers?.length || 0,
    newUsers: newTypingUsers.map(u => u.userName),
    oldUsers: oldTypingUsers?.map(u => u.userName) || []
  })

  // Clear existing timer
  if (typingNotificationTimer.value) {
    clearTimeout(typingNotificationTimer.value)
    typingNotificationTimer.value = null
  }

  // Always handle typing state changes - auto-scroll when someone is typing
  if (newTypingUsers.length > 0) {
    logger.debug('⌨️ Someone is typing, scrolling to bottom')
    await scrollToBottom()
  }
})

// Generate unique instance ID for debugging
const instanceId = Math.random().toString(36).substring(2, 8)

// Connection and room management
// Matrix ready event handler (defined outside onMounted for cleanup access)
const handleMatrixReady = () => {
  logger.debug('🎧 Matrix client ready - setting up timeline event listeners')
  setupMatrixEventListeners()
}

// Invalid token recovery event handler (resets UI state when tokens are cleared)
const handleInvalidTokenRecovery = () => {
  logger.debug('🚫 Invalid token recovery event received, resetting UI state')
  try {
    lastAuthError.value = 'Matrix authentication expired. Please click "Connect" to re-authenticate.'
    isConnecting.value = false
    messages.value = []
  } catch (error) {
    // Ignore Vue readonly property errors during cleanup
    console.warn('⚠️ Error during token recovery cleanup (expected during component teardown):', error.message)
  }
}

// Token error event handler (handles real-time token failures)
const handleTokenError = (event) => {
  logger.debug('🚫 Matrix token error received:', event.detail)
  logger.debug('🔧 Current UI state before token error handling:', {
    isConnected: isConnected.value,
    lastAuthError: lastAuthError.value,
    isConnecting: isConnecting.value
  })
  try {
    lastAuthError.value = 'Your session has expired. Please click "Connect" to re-authenticate.'
    isConnecting.value = false
    logger.debug('✅ Token error handled - Connect button should now be visible')
  } catch (error) {
    console.warn('⚠️ Error during token error handling:', error.message)
  }
}

// Token refresh failure event handler (handles SDK token refresh failures)
const handleTokenRefreshFailure = (event) => {
  logger.debug('🚫 Matrix token refresh failed:', event.detail)
  try {
    lastAuthError.value = 'Session expired and could not be renewed. Please click "Connect" to re-authenticate.'
    isConnecting.value = false
  } catch (error) {
    console.warn('⚠️ Error during token refresh failure handling:', error.message)
  }
}

onMounted(async () => {
  isConnecting.value = true

  // Listen for Matrix client ready events to ensure event listeners are set up
  window.addEventListener('matrix:ready', handleMatrixReady)

  // Listen for invalid token recovery events to reset UI state
  window.addEventListener('matrix:invalidTokenRecovery', handleInvalidTokenRecovery)

  // Listen for token error events to reactively show Connect button
  window.addEventListener('matrix:tokenError', handleTokenError)
  window.addEventListener('matrix:tokenRefreshFailure', handleTokenRefreshFailure)

  try {
    logger.debug(`🔌 [${instanceId}] MatrixChatInterface initializing for:`, {
      roomId: props.roomId,
      contextType: props.contextType,
      contextId: props.contextId,
      mode: props.mode
    })

    let messagesLoaded = false

    // Check if Matrix client is already ready
    if (matrixClientService.isReady()) {
      lastAuthError.value = '' // Clear any previous errors
      roomName.value = props.contextType === 'event' ? 'Event Chatroom' : props.contextType === 'group' ? 'Group Chatroom' : `${props.contextType} Chat`

      // Set up Matrix client event listeners (with duplicate protection)
      setupMatrixEventListeners()

      // Load messages only if we have a room ID
      if (props.roomId) {
        await loadMessages()
        await scrollToBottom()
        messagesLoaded = true
      }
    } else {
      // Try to initialize Matrix connection (but don't force auth)
      try {
        await matrixClientService.initializeClient()
      } catch (authError) {
        logger.debug('🔑 Matrix client needs authentication:', authError.message)
        // Don't throw - just log and show connect button to user
        lastAuthError.value = '' // Clear error to show connect button
        isConnecting.value = false
        return // Exit early to show connect button
      }

      // After successful Matrix connection, ensure we're invited to the chat room
      // This handles cases where the bot invitation failed during RSVP
      if (props.contextType === 'event' && props.contextId) {
        try {
          const result = await matrixClientService.joinEventChatRoom(props.contextId)
          // Force Matrix client to sync to pick up new invitation
          await matrixClientService.forceSyncAfterInvitation('event', props.contextId)
          // Update current room to use the actual room ID from join result
          if (result.room?.roomId) {
            // Using actual room ID from join result
            currentRoom.value = result.room
            // Load messages with the correct room ID
            await loadMessages()
          } else {
            // Fallback: update current room state and load messages
            await updateCurrentRoom()
            await loadMessages()
          }
        } catch (error) {
          console.warn('Failed to join event chat room:', error)
          // Don't throw - connection to Matrix itself succeeded
        }
      } else if (props.contextType === 'group' && props.contextId) {
        try {
          const result = await matrixClientService.joinGroupChatRoom(props.contextId)
          // Force Matrix client to sync to pick up new invitation
          await matrixClientService.forceSyncAfterInvitation('group', props.contextId)
          // Update current room to use the actual room ID from join result
          if (result.room?.roomId) {
            // Using actual room ID from join result
            currentRoom.value = result.room
            // Load messages with the correct room ID
            await loadMessages()
          } else {
            // Fallback: update current room state and load messages
            await updateCurrentRoom()
            await loadMessages()
          }
        } catch (error) {
          console.warn('Failed to join group chat room:', error)
          // Don't throw - connection to Matrix itself succeeded
        }
      }

      lastAuthError.value = '' // Clear any previous errors
      roomName.value = props.contextType === 'event' ? 'Event Chatroom' : props.contextType === 'group' ? 'Group Chatroom' : `${props.contextType} Chat`

      // Set up Matrix client event listeners (with duplicate protection)
      setupMatrixEventListeners()

      // Load messages if we have a room ID and we haven't loaded them already
      if (props.roomId && !messagesLoaded) {
        await loadMessages()
        await scrollToBottom()
      }
    }
  } catch (error) {
    console.error('❌ Failed to initialize Matrix chat:', error)
    lastAuthError.value = error.message || 'Connection failed'
  } finally {
    isConnecting.value = false
  }
})

// Component cleanup
onUnmounted(() => {
  logger.debug(`🧹 [${instanceId}] MatrixChatInterface cleanup started`)

  // Reset listener flag so next instance can set up listeners
  listenersSetUp = false

  // Cleanup Matrix ready event listener
  window.removeEventListener('matrix:ready', handleMatrixReady)

  // Cleanup invalid token recovery event listener
  window.removeEventListener('matrix:invalidTokenRecovery', handleInvalidTokenRecovery)

  // Cleanup token error event listeners
  window.removeEventListener('matrix:tokenError', handleTokenError)
  window.removeEventListener('matrix:tokenRefreshFailure', handleTokenRefreshFailure)

  // Cleanup custom event listeners
  customEventListeners.forEach(cleanup => cleanup())
  customEventListeners = []

  logger.debug(`🧹 [${instanceId}] MatrixChatInterface cleanup completed`)
})
</script>

<style scoped>
.matrix-chat-interface {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.mode-mobile {
  height: 100%;
}

.mode-inline {
  height: 100%;
}

.mode-desktop {
  height: 100%;
  max-height: 80vh;
}

.chat-header {
  flex-shrink: 0;
  border-bottom: 1px solid var(--q-separator-color);
}

.messages-container {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 0;
  display: flex;
  flex-direction: column;
}

.messages-list {
  flex: 1;
  padding: 1rem;
}

.message-item {
  margin-bottom: 0.75rem;
}

.own-message-item {
  margin-left: 20%;
  display: flex;
  justify-content: flex-end;
}

.other-message-item {
  margin-right: 20%;
  display: flex;
  justify-content: flex-start;
}

.message-content {
  max-width: 70%;
  min-width: 0;
  flex: 0 1 auto;
}

/* Base message body styles */
.message-body {
  padding: 0.75rem 1rem;
  display: inline-block;
  max-width: 100%;
  word-wrap: break-word;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Own message styling */
.own-message-item .message-body {
  background: var(--q-primary) !important;
  color: white !important;
  border-radius: 1rem 1rem 0.25rem 1rem !important;
}

/* Other users' message styling */
.other-message-item .message-body {
  background: #AF9EE8 !important;
  color: white !important;
  border-radius: 0.25rem 1rem 1rem 1rem !important;
  border: 1px solid rgba(0, 0, 0, 0.12) !important;
}

/* Dark mode overrides */
.q-dark .other-message-item .message-body {
  background: #4A3F66 !important;
  color: white !important;
  border-color: rgba(255, 255, 255, 0.2) !important;
}

.q-dark .own-message-item .message-body {
  background: #1976d2 !important;
  color: white !important;
}

/* Dark mode text visibility fixes */
.q-dark .message-time {
  color: rgba(255, 255, 255, 0.7) !important;
}

.q-dark .sender-name {
  color: rgba(255, 255, 255, 0.9) !important;
}

.q-dark .matrix-id-subscript {
  color: rgba(255, 255, 255, 0.6) !important;
}

.message-time {
  font-size: 0.75rem;
  opacity: 0.7;
  white-space: nowrap;
}

.sender-name {
  font-size: 0.8rem;
  margin-bottom: 0.25rem;
}

.matrix-id-subscript {
  font-size: 0.7rem;
  opacity: 0.6;
  margin-left: 0.25rem;
}

.avatar-fallback {
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
  border-radius: 50%;
}

.typing-indicator {
  padding: 0.5rem 1rem;
  font-style: italic;
  opacity: 0.7;
  background: var(--q-dark-page);
  border-radius: 18px;
  margin: 0.5rem;
  animation: pulse 1.5s ease-in-out infinite;
}

.input-container {
  flex-shrink: 0;
  padding: 1rem;
  border-top: 1px solid var(--q-separator-color);
  background: var(--q-card);
}

.connection-status {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 200px;
}

.emoji-picker-container {
  position: absolute;
  bottom: 60px;
  right: 1rem;
  z-index: 1000;
}

@keyframes pulse {
  0%, 100% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
}

.message-slide-enter-active {
  transition: all 0.3s ease-out;
}

.message-slide-enter-from {
  opacity: 0;
  transform: translateY(20px);
}

.message-slide-enter-to {
  opacity: 1;
  transform: translateY(0);
}

@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@media (max-width: 599px) {
  .own-message-item {
    margin-left: 10%;
  }

  .other-message-item {
    margin-right: 10%;
  }
}

/* Improved Message Styling */
.message-item {
  display: flex;
  gap: 0.75rem;
  margin-bottom: 0.75rem;
  align-items: flex-start;
}

.own-message-item {
  flex-direction: row-reverse;
  margin-left: 20%;
  justify-content: flex-start;
}

.other-message-item {
  flex-direction: row;
  margin-right: 20%;
  justify-content: flex-start;
}

.message-avatar {
  flex-shrink: 0;
  align-self: flex-start;
  margin-top: 0.25rem;
}

.avatar-fallback {
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 600;
  font-size: 0.9rem;
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.2);
}

.message-content {
  flex: 1;
  min-width: 0;
  max-width: 100%;
}

.sender-name {
  margin-bottom: 0.25rem;
}

.sender-display-name {
  font-size: 0.9rem;
  font-weight: 500;
}

.message-time {
  opacity: 0.7;
  font-size: 0.75rem;
  margin-left: 0.5rem;
}

.message-text {
  word-wrap: break-word;
  line-height: 1.4;
}

.text-message {
  position: relative;
}

.message-actions {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  opacity: 0.7;
  margin-top: 0.25rem;
}

.file-card {
  border-radius: 8px;
  background: #4238A6; /* Purple-500 from palette for white text readability */
  border: 1px solid #4238A6;
  max-width: 300px;
  transition: all 0.2s ease;
  color: white; /* White text for readability on dark background */
}

.file-card:hover {
  background: #5b4fc7; /* Slightly lighter purple on hover */
  border-color: #5b4fc7;
}

.file-name {
  font-weight: 500;
  word-break: break-word;
}

.file-actions {
  display: flex;
  gap: 0.25rem;
}

/* Authenticated image styling */
.authenticated-image-container {
  max-width: 400px;
}

.image-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2rem;
  min-height: 150px;
  justify-content: center;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 8px;
  margin: 0.5rem 0;
}

.message-image {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s ease;
}

.message-image:hover {
  transform: scale(1.02);
}

/* Dark mode support - duplicate rule removed */

.q-dark .avatar-fallback {
  border-color: rgba(255, 255, 255, 0.3);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

/* Light mode avatar improvements */
.avatar-fallback {
  border: 2px solid rgba(0, 0, 0, 0.1);
}

.q-dark .avatar-fallback {
  border: 2px solid rgba(255, 255, 255, 0.3);
}

.q-dark .file-card {
  background: rgba(255, 255, 255, 0.05);
  border-color: rgba(255, 255, 255, 0.1);
}

.q-dark .file-card:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.2);
}

</style>
