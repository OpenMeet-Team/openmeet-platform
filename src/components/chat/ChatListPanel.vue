<template>
  <div class="chat-list-panel">
    <!-- Header with search and filters -->
    <div class="chat-list-header q-pa-md">
      <div class="text-subtitle1 q-mb-md">
        {{ getHeaderTitle() }}
        <q-spinner v-if="isLoadingRooms" size="16px" class="q-ml-sm" />
        <q-badge v-else-if="realRooms.length > 0" color="green" class="q-ml-sm">{{ realRooms.length }}</q-badge>
        <q-badge v-else color="orange" class="q-ml-sm">demo</q-badge>
      </div>

      <!-- Search -->
      <q-input
        v-model="searchTerm"
        placeholder="Search chats..."
        dense
        outlined
        class="q-mb-sm"
      >
        <template v-slot:prepend>
          <q-icon name="sym_r_search" />
        </template>
        <template v-slot:append>
          <q-btn
            v-if="searchTerm"
            icon="clear"
            flat
            round
            dense
            @click="searchTerm = ''"
          />
        </template>
      </q-input>

      <!-- Filters for 'all' context -->
      <div v-if="contextType === 'all'" class="chat-filters q-mb-sm">
        <q-btn-toggle
          v-model="chatFilter"
          :options="[
            { label: 'All', value: 'all' },
            { label: 'Direct', value: 'direct' },
            { label: 'Groups', value: 'group' },
            { label: 'Events', value: 'event' }
          ]"
          color="primary"
          size="sm"
          dense
          class="full-width"
        />
      </div>

      <!-- Enhanced controls row -->
      <div class="row q-gutter-xs">
        <!-- Sort options -->
        <q-select
          v-model="sortBy"
          :options="[
            { label: 'Recent Activity', value: 'activity' },
            { label: 'Name (A-Z)', value: 'name' },
            { label: 'Unread First', value: 'unread' },
            { label: 'Type', value: 'type' }
          ]"
          option-label="label"
          option-value="value"
          emit-value
          map-options
          dense
          outlined
          style="min-width: 120px;"
          label="Sort by"
          class="col"
        />

        <!-- Show only unread toggle -->
        <q-btn
          :color="showUnreadOnly ? 'primary' : 'grey-5'"
          :outline="!showUnreadOnly"
          :unelevated="showUnreadOnly"
          icon="sym_r_notifications"
          size="sm"
          @click="showUnreadOnly = !showUnreadOnly"
          class="q-px-sm"
        >
          <q-tooltip>{{ showUnreadOnly ? 'Show all chats' : 'Show only unread' }}</q-tooltip>
        </q-btn>

        <!-- Settings menu -->
        <q-btn
          color="grey-5"
          outline
          icon="sym_r_settings"
          size="sm"
          class="q-px-sm"
        >
          <q-menu>
            <q-list style="min-width: 150px">
              <q-item clickable @click="refreshRooms">
                <q-item-section avatar>
                  <q-icon name="sym_r_refresh" />
                </q-item-section>
                <q-item-section>Refresh</q-item-section>
              </q-item>
              <q-item clickable @click="markAllRead">
                <q-item-section avatar>
                  <q-icon name="sym_r_done_all" />
                </q-item-section>
                <q-item-section>Mark All Read</q-item-section>
              </q-item>
            </q-list>
          </q-menu>
        </q-btn>
      </div>
    </div>

    <!-- Chat List -->
    <div class="chat-list q-pa-sm">
      <q-list>
        <!-- Recent Chats Section -->
        <q-item-label header v-if="recentChats.length > 0">
          Recent
        </q-item-label>

        <q-item
          v-for="chat in filteredRecentChats"
          :key="chat.id"
          clickable
          @click="$emit('select-chat', chat)"
          :class="{ 'bg-blue-1': selectedChatId === chat.id }"
          class="chat-item"
        >
          <q-item-section avatar>
            <q-badge
              v-if="chat.unreadCount && chat.unreadCount > 0"
              :label="chat.unreadCount"
              color="red"
              floating
            >
              <q-avatar size="40px" :color="getChatColor(chat)" text-color="white">
                <q-icon :name="getChatIcon(chat)" />
              </q-avatar>
            </q-badge>
            <q-avatar v-else size="40px" :color="getChatColor(chat)" text-color="white">
              <q-icon :name="getChatIcon(chat)" />
            </q-avatar>
          </q-item-section>

          <q-item-section>
            <q-item-label lines="1" class="text-weight-medium">
              {{ chat.name }}
            </q-item-label>
            <q-item-label caption lines="1">
              {{ chat.lastMessage || getChatSubtitle(chat) }}
            </q-item-label>
          </q-item-section>

          <q-item-section side>
            <div class="column items-end">
              <div v-if="chat.lastActivity" class="text-caption text-grey-6">
                {{ formatTime(chat.lastActivity) }}
              </div>
              <q-icon
                v-if="chat.isEncrypted"
                name="sym_r_lock"
                size="12px"
                color="green"
                class="q-mt-xs"
              />
            </div>
          </q-item-section>
        </q-item>

        <!-- Available Chats Section -->
        <q-item-label header v-if="availableChats.length > 0" class="q-mt-md">
          Available
        </q-item-label>

        <q-item
          v-for="chat in filteredAvailableChats"
          :key="chat.id"
          clickable
          @click="joinChat(chat)"
          class="chat-item available-chat"
        >
          <q-item-section avatar>
            <q-avatar size="40px" :color="getChatColor(chat)" text-color="white">
              <q-icon :name="getChatIcon(chat)" />
            </q-avatar>
          </q-item-section>

          <q-item-section>
            <q-item-label lines="1" class="text-weight-medium">
              {{ chat.name }}
            </q-item-label>
            <q-item-label caption lines="1">
              {{ getChatSubtitle(chat) }}
            </q-item-label>
          </q-item-section>

          <q-item-section side>
            <q-btn
              icon="sym_r_add"
              size="sm"
              round
              flat
              color="primary"
              @click.stop="joinChat(chat)"
            />
          </q-item-section>
        </q-item>

        <!-- Empty State -->
        <div v-if="filteredRecentChats.length === 0 && filteredAvailableChats.length === 0" class="empty-state q-pa-lg text-center">
          <q-icon :name="getEmptyIcon()" size="48px" color="grey-5" />
          <div class="text-h6 q-mt-md text-grey-6">{{ getEmptyTitle() }}</div>
          <div class="text-body2 text-grey-5">{{ getEmptySubtitle() }}</div>

          <!-- Action buttons for different contexts -->
          <div v-if="contextType === 'all'" class="q-mt-md">
            <q-btn
              label="Start Direct Message"
              color="primary"
              outline
              @click="startDirectMessage"
              class="q-mb-sm"
            />
            <br>
            <q-btn
              label="Browse Groups"
              color="purple"
              outline
              @click="browseGroups"
            />
          </div>
        </div>
      </q-list>
    </div>

    <!-- Floating Action Button for mobile -->
    <q-page-sticky position="bottom-right" :offset="[18, 18]" class="gt-xs-hide">
      <q-btn
        fab
        icon="sym_r_add"
        color="primary"
        @click="showNewChatDialog = true"
      />
    </q-page-sticky>

    <!-- New Chat Dialog -->
    <q-dialog v-model="showNewChatDialog">
      <q-card style="min-width: 350px">
        <q-card-section>
          <div class="text-h6">Start New Chat</div>
        </q-card-section>

        <q-card-section>
          <q-btn-toggle
            v-model="newChatType"
            :options="[
              { label: 'Direct Message', value: 'direct', icon: 'sym_r_person' },
              { label: 'Find Group', value: 'group', icon: 'sym_r_group' },
              { label: 'Find Event', value: 'event', icon: 'sym_r_event' }
            ]"
            color="primary"
            class="full-width q-mb-md"
          />

          <q-input
            v-model="newChatSearch"
            :placeholder="getNewChatPlaceholder()"
            dense
            outlined
            autofocus
            @keyup.enter="searchNewChat"
          >
            <template v-slot:append>
              <q-btn
                icon="search"
                flat
                round
                dense
                @click="searchNewChat"
                :loading="isSearching"
              />
            </template>
          </q-input>

          <!-- Search Results -->
          <q-list v-if="newChatResults.length > 0" class="q-mt-md">
            <q-item
              v-for="result in newChatResults"
              :key="result.id"
              clickable
              @click="startNewChat(result)"
            >
              <q-item-section avatar>
                <q-avatar size="32px" :color="getChatColor(result)" text-color="white">
                  <q-icon :name="getChatIcon(result)" />
                </q-avatar>
              </q-item-section>
              <q-item-section>
                <q-item-label>{{ result.name }}</q-item-label>
                <q-item-label caption>{{ result.description }}</q-item-label>
              </q-item-section>
            </q-item>
          </q-list>
        </q-card-section>

        <q-card-actions align="right">
          <q-btn flat label="Cancel" v-close-popup />
        </q-card-actions>
      </q-card>
    </q-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { matrixClientService } from '../../services/matrixClientService'
import { groupsApi } from '../../api/groups'
import { eventsApi } from '../../api/events'
import { formatDistanceToNow } from 'date-fns'
import { Room, RoomMember, ClientEvent } from 'matrix-js-sdk'
import type { GroupEntity, EventEntity } from '../../types'

interface Chat {
  id: string
  name: string
  type: 'direct' | 'group' | 'event'
  matrixRoomId: string
  lastMessage?: string
  lastActivity?: Date
  unreadCount?: number
  participants?: Array<{ id: string; name: string; avatar?: string }>
  isEncrypted?: boolean
  description?: string
}

interface Props {
  contextType: 'all' | 'direct' | 'group' | 'event'
  contextId?: string
  selectedChatId?: string
}

const props = defineProps<Props>()

const emit = defineEmits<{
  'select-chat': [chat: Chat]
}>()

// State
const searchTerm = ref('')
const chatFilter = ref('all')
const sortBy = ref('activity')
const showUnreadOnly = ref(false)
const showNewChatDialog = ref(false)
const newChatType = ref('direct')
const newChatSearch = ref('')
const newChatResults = ref<Chat[]>([])
const isSearching = ref(false)

const router = useRouter()
// Use Matrix client service directly

// Real Matrix rooms state with persistence (caching currently disabled)
// const ROOMS_CACHE_KEY = 'openmeet_cached_rooms'
// const CACHE_EXPIRY_MS = 5 * 60 * 1000 // 5 minutes

const realRooms = ref<Chat[]>([])
const isLoadingRooms = ref(false)

// Load cached rooms from localStorage (currently unused)
// const loadCachedRooms = (): Chat[] => {
//   try {
//     const cached = localStorage.getItem(ROOMS_CACHE_KEY)
//     if (!cached) return []

//     const { data, timestamp } = JSON.parse(cached)

//     // Check if cache has expired
//     if (Date.now() - timestamp > CACHE_EXPIRY_MS) {
//       localStorage.removeItem(ROOMS_CACHE_KEY)
//       return []
//     }

//     // Convert cached data back to proper format
//     return data.map((room: any) => ({
//       ...room,
//       lastActivity: room.lastActivity ? new Date(room.lastActivity) : null
//     }))
//   } catch (error) {
//     console.warn('⚠️ Failed to load cached rooms:', error)
//     return []
//   }
// }

// Save rooms to localStorage (currently unused)
// const cacheRooms = (rooms: Chat[]) => {
//   try {
//     const cacheData = {
//       data: rooms,
//       timestamp: Date.now()
//     }
//     localStorage.setItem(ROOMS_CACHE_KEY, JSON.stringify(cacheData))
//   } catch (error) {
//     console.warn('⚠️ Failed to cache rooms:', error)
//   }
// }

// Load ALL Matrix rooms that user has joined, then identify which are OpenMeet rooms
const loadRealRooms = async () => {
  isLoadingRooms.value = true
  try {
    console.log('🔄 Loading ALL Matrix rooms user has joined...')

    // Initialize Matrix client to get actual room information
    const matrixClient = await matrixClientService.initializeClient()
    if (!matrixClient) {
      console.warn('⚠️ No Matrix client available')
      return
    }

    // Get ALL Matrix rooms from client
    const matrixRooms = matrixClient.getRooms() || []
    console.log('🏠 Matrix client has', matrixRooms.length, 'total rooms')

    if (matrixRooms.length === 0) {
      console.log('ℹ️ No Matrix rooms found - user may not be in any rooms yet')
      return
    }

    // Get user's OpenMeet groups and events for context (optional)
    let groups: GroupEntity[] = []
    let events: EventEntity[] = []

    try {
      const [groupsResponse, eventsResponse] = await Promise.all([
        groupsApi.getAllMe(), // User's joined groups
        eventsApi.getDashboardEvents() // User's events
      ])
      groups = groupsResponse.data
      events = eventsResponse.data
      console.log('📋 Found', groups.length, 'OpenMeet groups and', events.length, 'events for context')
    } catch (apiError) {
      console.warn('⚠️ Could not load OpenMeet groups/events, will show Matrix rooms without context:', apiError)
    }

    // Create lookup maps for OpenMeet context
    const groupsByRoomId = new Map()
    const eventsByRoomId = new Map()

    groups.forEach(group => {
      if (group.roomId) groupsByRoomId.set(group.roomId, group)
    })

    events.forEach(event => {
      if (event.roomId) eventsByRoomId.set(event.roomId, event)
    })

    // Convert ALL Matrix rooms to chat format
    const allChats: Chat[] = []

    matrixRooms.forEach(matrixRoom => {
      const roomId = matrixRoom.roomId
      const lastMessage = getLastMessage(matrixRoom)
      const unreadCount = getUnreadCount(matrixRoom)
      const participants = getParticipants(matrixRoom)

      // Try to identify what type of room this is
      let roomName = matrixRoom.name || 'Unnamed Room'
      let roomType: 'group' | 'event' | 'direct' = 'direct' // Default
      let description: string | undefined
      let chatId: string

      // Check if it's a known OpenMeet group room
      const linkedGroup = groupsByRoomId.get(roomId)
      if (linkedGroup) {
        roomName = linkedGroup.name
        roomType = 'group'
        description = linkedGroup.description
        chatId = `group-${linkedGroup.slug}`
      } else {
        // Check if it's a known OpenMeet event room
        const linkedEvent = eventsByRoomId.get(roomId)
        if (linkedEvent) {
          roomName = linkedEvent.name
          roomType = 'event'
          description = linkedEvent.description
          chatId = `event-${linkedEvent.slug}`
        } else {
          // Check room alias to infer type
          const canonicalAlias = matrixRoom.getCanonicalAlias()
          const altAliases = matrixRoom.getAltAliases()
          const allAliases = [canonicalAlias, ...altAliases].filter(Boolean)

          // Look for OpenMeet room alias patterns
          const groupAlias = allAliases.find(alias => alias?.startsWith('#group-'))
          const eventAlias = allAliases.find(alias => alias?.startsWith('#event-'))

          if (groupAlias) {
            roomType = 'group'
            chatId = `matrix-group-${roomId}`
            console.log(`🏷️ Found group room via alias: ${groupAlias}`)
          } else if (eventAlias) {
            roomType = 'event'
            chatId = `matrix-event-${roomId}`
            console.log(`🏷️ Found event room via alias: ${eventAlias}`)
          } else {
            // Assume direct message if 2 members, otherwise generic room
            roomType = participants.length <= 2 ? 'direct' : 'group'
            chatId = `matrix-${roomType}-${roomId}`
          }
        }
      }

      allChats.push({
        id: chatId,
        name: roomName,
        type: roomType,
        matrixRoomId: roomId,
        lastMessage: lastMessage?.body || lastMessage?.msgtype || undefined,
        lastActivity: lastMessage ? new Date(lastMessage.origin_server_ts) : undefined,
        unreadCount,
        participants,
        isEncrypted: matrixRoom.hasEncryptionStateEvent(),
        description
      })
    })

    // Sort by last activity (most recent first), then by name
    realRooms.value = allChats.sort((a, b) => {
      // Sort by last activity (most recent first)
      if (!a.lastActivity && !b.lastActivity) return a.name.localeCompare(b.name)
      if (!a.lastActivity) return 1
      if (!b.lastActivity) return -1
      return b.lastActivity.getTime() - a.lastActivity.getTime()
    })

    console.log('🏠 Loaded', realRooms.value.length, 'Matrix rooms:')
    realRooms.value.forEach((room, index) => {
      const activity = room.lastActivity ? room.lastActivity.toLocaleString() : 'no activity'
      const unread = room.unreadCount ? `(${room.unreadCount} unread)` : ''
      const context = room.description ? ' - ' + room.description.substring(0, 50) : ''
      console.log(`  ${index + 1}. ${room.name} (${room.type}) - ${activity} ${unread}${context}`)
    })
  } catch (error) {
    console.error('❌ Failed to load Matrix rooms:', error)
    console.error('   Error details:', error.message)
    // No fallback - real data only
  } finally {
    isLoadingRooms.value = false
  }
}

// Helper functions for Matrix room data extraction
const getLastMessage = (room: Room) => {
  const timeline = room.getLiveTimeline()
  const events = timeline.getEvents()

  // Find the last message event (ignore state events, reactions, etc.)
  for (let i = events.length - 1; i >= 0; i--) {
    const event = events[i]
    if (event.getType() === 'm.room.message' && !event.isRedacted()) {
      return {
        body: event.getContent().body,
        msgtype: event.getContent().msgtype,
        origin_server_ts: event.getTs(),
        sender: event.getSender()
      }
    }
  }
  return null
}

const getUnreadCount = (room: Room): number => {
  // Get unread count from Matrix room
  const unreadCount = room.getUnreadNotificationCount()
  return unreadCount > 0 ? unreadCount : 0
}

const getParticipants = (room: Room) => {
  const members = room.getJoinedMembers()
  return members.map((member: RoomMember) => ({
    id: member.userId,
    name: member.name || member.userId,
    avatar: member.getAvatarUrl('', 32, 32, 'crop', false, false) || undefined
  }))
}

// Initialize Matrix and load chats on component mount
onMounted(async () => {
  try {
    console.log('🚀 ChatListPanel mounted, checking Matrix connection...')

    // Only initialize if user has already chosen to connect to Matrix
    if (!matrixClientService.hasUserChosenToConnect()) {
      console.log('💭 User has not chosen to connect to Matrix - skipping initialization')
      return
    }

    const matrixClient = await matrixClientService.initializeClient()
    console.log('✅ Message store Matrix initialized')

    // Listen for Matrix sync completion to refresh room list
    if (matrixClient) {
      matrixClient.on(ClientEvent.Sync, (state: string) => {
        console.log('🔄 Matrix sync state:', state, 'Current rooms:', realRooms.value.length)
        if (state === 'PREPARED' && realRooms.value.length === 0) {
          console.log('🔄 Matrix sync completed, refreshing room list')
          loadRealRooms()
        }
      })
    }

    await loadRealRooms()
  } catch (error) {
    console.error('❌ Failed to load chats:', error)
  }
})

// Enhanced sorting function
const sortChats = (chats: Chat[]): Chat[] => {
  return [...chats].sort((a, b) => {
    switch (sortBy.value) {
      case 'name':
        return a.name.localeCompare(b.name)
      case 'unread': {
        // Unread first, then by recent activity
        const unreadDiff = (b.unreadCount || 0) - (a.unreadCount || 0)
        if (unreadDiff !== 0) return unreadDiff
        return (b.lastActivity?.getTime() || 0) - (a.lastActivity?.getTime() || 0)
      }
      case 'type': {
        // Sort by type, then by name
        const typeDiff = a.type.localeCompare(b.type)
        if (typeDiff !== 0) return typeDiff
        return a.name.localeCompare(b.name)
      }
      case 'activity':
      default:
        return (b.lastActivity?.getTime() || 0) - (a.lastActivity?.getTime() || 0)
    }
  })
}

// Get recent chats - real data only
const recentChats = computed(() => {
  const chats = realRooms.value.filter(chat =>
    chat.lastActivity &&
    (Date.now() - chat.lastActivity.getTime()) < 7 * 24 * 60 * 60 * 1000 // Last 7 days
  )
  return sortChats(chats)
})

// Get available chats - real data only
const availableChats = computed(() => {
  const chats = realRooms.value.filter(chat =>
    !chat.lastActivity ||
    (Date.now() - chat.lastActivity.getTime()) >= 7 * 24 * 60 * 60 * 1000
  )
  return sortChats(chats)
})

// Enhanced filtering with unread-only and better search
const filteredRecentChats = computed(() => {
  return recentChats.value.filter(chat => {
    // Search filter
    const matchesSearch = !searchTerm.value ||
      chat.name.toLowerCase().includes(searchTerm.value.toLowerCase()) ||
      (chat.lastMessage && chat.lastMessage.toLowerCase().includes(searchTerm.value.toLowerCase())) ||
      (chat.description && chat.description.toLowerCase().includes(searchTerm.value.toLowerCase())) ||
      chat.participants?.some(p => p.name.toLowerCase().includes(searchTerm.value.toLowerCase()))

    // Type filter
    const matchesFilter = chatFilter.value === 'all' || chat.type === chatFilter.value
    const matchesContext = props.contextType === 'all' || chat.type === props.contextType

    // Unread filter
    const matchesUnread = !showUnreadOnly.value || (chat.unreadCount && chat.unreadCount > 0)

    return matchesSearch && matchesFilter && matchesContext && matchesUnread
  })
})

const filteredAvailableChats = computed(() => {
  return availableChats.value.filter(chat => {
    // Search filter
    const matchesSearch = !searchTerm.value ||
      chat.name.toLowerCase().includes(searchTerm.value.toLowerCase()) ||
      (chat.description && chat.description.toLowerCase().includes(searchTerm.value.toLowerCase()))

    // Type filter
    const matchesFilter = chatFilter.value === 'all' || chat.type === chatFilter.value
    const matchesContext = props.contextType === 'all' || chat.type === props.contextType

    return matchesSearch && matchesFilter && matchesContext
  })
})

// Methods
const getHeaderTitle = (): string => {
  switch (props.contextType) {
    case 'direct': return 'Direct Messages'
    case 'group': return 'Group Discussions'
    case 'event': return 'Event Discussions'
    default: return 'All Chats'
  }
}

const getChatColor = (chat: Chat): string => {
  switch (chat.type) {
    case 'direct': return 'blue'
    case 'group': return 'purple'
    case 'event': return 'green'
    default: return 'grey'
  }
}

const getChatIcon = (chat: Chat): string => {
  switch (chat.type) {
    case 'direct': return chat.isEncrypted ? 'sym_r_lock' : 'sym_r_person'
    case 'group': return 'sym_r_group'
    case 'event': return 'sym_r_event'
    default: return 'sym_r_chat'
  }
}

const getChatSubtitle = (chat: Chat): string => {
  const count = chat.participants?.length || 0

  switch (chat.type) {
    case 'direct': return 'Direct message'
    case 'group': return `${count} members`
    case 'event': return 'Event discussion'
    default: return ''
  }
}

const formatTime = (date: Date): string => {
  return formatDistanceToNow(date, { addSuffix: true })
}

const getEmptyIcon = (): string => {
  switch (props.contextType) {
    case 'direct': return 'sym_r_person'
    case 'group': return 'sym_r_group'
    case 'event': return 'sym_r_event'
    default: return 'sym_r_chat'
  }
}

const getEmptyTitle = (): string => {
  switch (props.contextType) {
    case 'direct': return 'No direct messages'
    case 'group': return 'No group discussions'
    case 'event': return 'No event discussions'
    default: return 'No chats'
  }
}

const getEmptySubtitle = (): string => {
  switch (props.contextType) {
    case 'direct': return 'Start a conversation with someone'
    case 'group': return 'Join a group to start chatting'
    case 'event': return 'Join an event to participate in discussions'
    default: return 'Start a new conversation or join a group'
  }
}

const getNewChatPlaceholder = (): string => {
  switch (newChatType.value) {
    case 'direct': return 'Search for a person...'
    case 'group': return 'Search for a group...'
    case 'event': return 'Search for an event...'
    default: return 'Search...'
  }
}

const joinChat = async (chat: Chat) => {
  // Call API to join the chat/room
  // Then emit the select event
  emit('select-chat', chat)
}

const startDirectMessage = () => {
  showNewChatDialog.value = true
  newChatType.value = 'direct'
}

const browseGroups = () => {
  router.push('/groups')
}

const refreshRooms = async () => {
  console.log('🔄 Refreshing room list...')
  await loadRealRooms()
}

const markAllRead = async () => {
  try {
    const matrixClient = await matrixClientService.initializeClient()
    if (!matrixClient) return

    console.log('📖 Marking all rooms as read...')

    // Mark all rooms as read
    for (const chat of realRooms.value) {
      if (chat.unreadCount && chat.unreadCount > 0) {
        const room = matrixClient.getRoom(chat.matrixRoomId)
        if (room) {
          const timeline = room.getLiveTimeline()
          const events = timeline.getEvents()
          if (events.length > 0) {
            const lastEvent = events[events.length - 1]
            await matrixClient.sendReadReceipt(lastEvent)
          }
        }
      }
    }

    // Refresh the room list to update unread counts
    await loadRealRooms()
    console.log('✅ All rooms marked as read')
  } catch (error) {
    console.error('❌ Failed to mark all rooms as read:', error)
  }
}

const searchNewChat = async () => {
  if (!newChatSearch.value.trim()) return

  isSearching.value = true
  try {
    // Call appropriate API based on newChatType
    // Mock results for now
    newChatResults.value = [
      {
        id: 'search-1',
        name: newChatSearch.value,
        type: newChatType.value as 'direct' | 'group' | 'event',
        matrixRoomId: '',
        description: `Search result for ${newChatSearch.value}`
      }
    ]
  } finally {
    isSearching.value = false
  }
}

const startNewChat = async (result: Chat) => {
  // Create or join the chat based on the search result
  showNewChatDialog.value = false
  newChatSearch.value = ''
  newChatResults.value = []

  // Add to recent chats and select
  recentChats.value.unshift(result)
  emit('select-chat', result)
}

// Load chats on mount
onMounted(async () => {
  // Load chats based on context
  // await chatStore.loadChats(props.contextType, props.contextId)
})
</script>

<style scoped>
.chat-list-panel {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.chat-list {
  flex: 1;
  overflow-y: auto;
}

.chat-item {
  margin-bottom: 4px;
  border-radius: 8px;
}

.chat-item:hover {
  background-color: rgba(0, 0, 0, 0.04);
}

/* Dark mode hover */
.q-dark .chat-item:hover {
  background-color: rgba(255, 255, 255, 0.08);
}

.available-chat {
  opacity: 0.8;
}

.available-chat:hover {
  opacity: 1;
}

.empty-state {
  margin-top: 40px;
}

.chat-filters {
  margin-bottom: 8px;
}
</style>
